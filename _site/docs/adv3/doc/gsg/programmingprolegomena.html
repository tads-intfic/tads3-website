<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title>docs-adv3-doc-gsg-programmingprolegomena-html</title>
    <meta property="og:title" content=
    "docs-adv3-doc-gsg-programmingprolegomena-html">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header><div class="header-search">
    <form class="header-search-form" action="/search/" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<div class="topbar">

[<img src="topbar.jpg" data-border="0" />](index.html)

</div>

<p><a href="index.html">[Main]</a><br />
<em><a href="creatingyourfirsttads3project.html">[Previous]</a>
  <a href="furtherprogramming.html">[Next]</a></em></p>

<h2 id="programming-prolegomena">Programming Prolegomena</h2>

<p>Many readers may prefer to skip this section altogether and dive
straight into the more interesting business of writing a game. But if
you are completely new to programming in TADS (or TADS 3) you may
appreciate a brief introduction to some of the basic ground rules. This
section makes no attempt to give a comprehensive or systematic account
of the TADS 3 language, but simply introduces some of the things you
will be meeting in this <em>Getting Started</em> Guide.</p>

<h3 id="a-overview-of-basic-concepts">a. Overview of Basic Concepts</h3>

<p>Writing a game in TADS 3 requires two different styles of programming:
<em>declarative</em> and <em>procedural</em>. <em>Declarative</em> programming is largely a
matter of defining <em>objects</em> and setting their <em>properties</em> (see below).
Setting the properties of objects means giving them <em>values</em>; a <em>value</em>
may typically be a number, a string (i.e. a piece of text) or another
object. Since adv3, the library that comes with TADS 3, is so rich, you
can achieve a great deal in TADS 3 with declarative programming alone.</p>

<p><em>Procedural</em> programming involves writing a sequence of <em>statements</em>.
Each <em>statement</em> is an instruction that you want your game to carry out.
Statements may typically assign a value to a <em>variable</em> or property, or
call a <em>function</em> or <em>method</em>. A <em>variable</em> is a kind of temporary store
for a value; a property can act as a more permanent store.</p>

<p>With one or two exceptions we needn’t worry about here, statements can
appear only in <em>functions</em> and <em>methods</em>; there needs to be some context
in which they are executed. Similarly, <em>variables</em> can only be used in
<em>functions</em> and <em>methods</em>; all TADS 3 variables are thus <em>local</em>
variables (see further below).</p>

<p>A <em>function</em> is a kind of wrapper for a group of related statements you
want to be executed together. An individual function is usually designed
to carry out one specific task (although it may be a highly complex task
involving many individual steps). The process of telling TADS 3 that we
want a function to carry out its task is known as <em>calling</em> or
<em>invoking</em> the function (the two terms are synonymous).</p>

<p>A <em>method</em> is similar to a function, but is associated with a particular
<em>object</em>. A function can be invoked (i.e. called) simply using its name
(e.g. the statement <code class="language-plaintext highlighter-rouge">foo()</code> will invoke the
function named <code class="language-plaintext highlighter-rouge">foo</code>), whereas invoking a method
generally requires specifying the name of the object to which it belongs
as well (e.g. <code class="language-plaintext highlighter-rouge">foo.bar()</code> would invoke the bar
method of the <code class="language-plaintext highlighter-rouge">foo</code> object). The exception is
when a method is invoked from another method of the same object.</p>

<h3 id="b-objects">b. Objects</h3>

<p>Broadly speaking, most programming in TADS consists of defining
<em>objects</em> (although you may also find yourself defining classes,
functions, and one or two other things, but we’ll leave those to one
side for the moment). An object may be an object in the physical sense
of something that appears in your game world, such as a spade, a
cottage, or a shopkeeper, but it may also be a more abstract construct
designed to do some job or other in your code. Examples of some of
abstract objects we shall be encountering include ActorStates that help
describe how an actor behaves under particular circumstances, and
TopicEntries that define how an actor responds to various questions.</p>

<p>Objects generally belong in some form of <em>containment hierarchy.</em> For
physical objects this usually represents the notional containment
relationships in your game world. At the top of the hierarchy are the
rooms (locations) that make up the map of your world. Each individual
room may contain a number of objects, such as tables, chairs, rocks,
boxes and the like, as well as actors such as the player character (PC)
and non-player characters (NPCs). These in turn may ‘contain’ further
objects (and so on). For example, if there is coin inside one of the
boxes, the coin is contained by the box, just as the box is contained by
the room. ‘Containment’ is, however, a slightly more general relation
than this example might suggest. For example, if a pen is sitting on the
table, then the table is considered to be the pen’s container. Anything
held (or worn) by an actor is considered to be contained by the actor.
So, for example, if the PC picks up one of the rocks, that rock’s
container changes from the room to the PC. If the PC then puts one of
the boxes on the table, the box is now ‘contained’ by the table instead
of directly by the room (although it remains indirectly contained by the
room). At this point the coin is contained by the box, but is also ‘in’
the table and the room. In TADS 3 the immediately container of an object
is always specified in its <code class="language-plaintext highlighter-rouge">location</code> property.</p>

<p>Containment may also be used to relate abstract objects. For example,
menu items may be contained in a menu, or an actor may ‘contain’
abstract objects such as ActorStates and TopicEntries (these will be
explained in due course) as well as physical objects being carried
around by the actor.</p>

<p>Typically an object definition begins with the name of an object,
followed by a colon, followed by a class list, followed by a list of its
<em>properties</em> and <em>methods</em>:</p>

<p>myObj: Thing
  name = ‘boring object’
  changeName
  {
    name = ‘even more boring object’;
  }  ;</p>

<p>In this definition <code class="language-plaintext highlighter-rouge">name</code> is a <em>property</em> of
<code class="language-plaintext highlighter-rouge">myObj</code>, <code class="language-plaintext highlighter-rouge">changeName</code> is
a <em>method</em> and <code class="language-plaintext highlighter-rouge">Thing</code> is the <em>class</em> (or
<em>superclass</em> or <em>base class</em>) of the object. The functional difference
between a <em>property</em> and a <em>method</em> is that properties hold values while
methods contain code: a list of one or more statements that do something
when the method is invoked. The syntactical difference is that the name
of a property is separated from its value by an equals sign (=) while
that of a method is not, the statements that make up the method being
enclosed in braces { }.</p>

<p>A further point of syntax to note is the use of the semicolon. This is
used (a) to terminate the object definition, and (b) to terminate
statements. It is <em>not</em> used to terminate property definitions (a very,
very easy mistake to make). Although they look very similar, the line
<code class="language-plaintext highlighter-rouge">name = 'boring object'</code> is a property
definition that means “define a <code class="language-plaintext highlighter-rouge">name</code> property
on <code class="language-plaintext highlighter-rouge">myObj</code> and set its initial value to ‘boring
object’”, while the statement within the
<code class="language-plaintext highlighter-rouge">changeName</code> method, i.e.
<code class="language-plaintext highlighter-rouge">name = 'even more boring object'; </code>is an
assignment statement that means “change the value of the already
existing value of the <code class="language-plaintext highlighter-rouge">name</code> property to ‘even
more boring object’.”</p>

<p>Note that you could use braces instead of a terminating semicolon to
define the extent of the object definition; the foregoing object
definition could then have been written:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  myObj: Thing  {
  name = 'boring object'
  changeName
  {

    name = 'even more boring object';
  }
  }
</code></pre></div></div>
<p>Which you use is up to you, but this <em>Guide</em> will use the terminating
semicolon.</p>

<h3 id="c-assignment-statements">c. Assignment Statements</h3>

<p>An assignment statement is probably one of the most common kinds of
statement that you will come across in TADS 3 programming. It always
takes the form:</p>

<p>lvalue = expression;</p>

<p>Where <code class="language-plaintext highlighter-rouge">lvalue </code>can be either an object property
or a variable (which we’ll talk about in just a bit). An expression can
be as simple as a constant value or the name of another variable, a
function call or method name (assuming the function or method returns a
suitable value), or a more complex expression involving a number of the
foregoing elements joined together with <em>operators</em>, for example:</p>

<p>myName = ‘my ‘ + name;</p>

<p>As a statement this would assign the value ‘my boring object’ to the
variable <code class="language-plaintext highlighter-rouge">myName</code> (assuming that
<code class="language-plaintext highlighter-rouge">name </code>started off by holding the value ‘boring
object’). Note that an expression can also be used as the value of a
<em>property</em> (in which case it should be enclosed in parentheses), so that
if we made <code class="language-plaintext highlighter-rouge">myName</code> a <em>property</em> of
<code class="language-plaintext highlighter-rouge">myObj</code>, we could definine it thus:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myObj: Thing
  name = 'boring object'
  changeName
  {

    name = 'even more boring object'
    ;
  }
  myName = ('my ' + name)
  ;
</code></pre></div></div>
<p>This definition would mean that <code class="language-plaintext highlighter-rouge">myName</code>
contained ‘my boring object’ until the
<code class="language-plaintext highlighter-rouge">changeName</code> method was invoked, and would
contain ‘my even more boring object’ afterwards (we’ll talk about
invoking methods presently). In fact, it is, except for its appearance,
<em>exactly</em> the same as writing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myName  { return 'my ' + name; }
</code></pre></div></div>
<p>When it is used with (single-quoted) strings, + is thus a concatenation
operator. With numbers it does what you would expect, i.e. add them
together, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myNumber = 3 + 4;
</code></pre></div></div>
<p>Would assign the number 7 to <code class="language-plaintext highlighter-rouge">myNumber</code>. All the
numbers we’ll be dealing with in this Guide will be <em>integers</em> (i.e.
whole numbers); TADS 3 does possess a
<code class="language-plaintext highlighter-rouge">BigNumber</code> class that allows you to work with
real numbers (i.e. numbers including a fractional part, such as
3.14159), but most Interactive Fiction can get by quite happily with
standard integer arithmetic.</p>

<p>Other common arithmetic operators include -, * and / (subtract,
multiply and divide) which do much what you would expect (note that the
division is integer division, so that <code class="language-plaintext highlighter-rouge">myNumber = 3 /
4 </code>would set <code class="language-plaintext highlighter-rouge">myNumber</code> to zero, while
<code class="language-plaintext highlighter-rouge">myNumber = 10 / 4 </code>would set it to 2). Less
obvious but almost just as common and useful are the various shortcut
operators that provide a more concise way of coding common operations.
There are several of these, but the only ones we need deal with here are
+= -= ++ and –. It is quite common in programming to want to add or
subtract a number from the current value of a variable or property and
store the result in the same variable or property, e.g.:</p>

<p>myNumber = myNumber + 4;  myNumber = myNumber - 2;</p>

<p>If <code class="language-plaintext highlighter-rouge">myNumber</code> started out at 6, then after the
first line was executed, myNumber would be changed to 10, and after the
second line was executed, it would be changed to 8. This could be
written more succinctly as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myNumber += 4;  myNumber -= 2;
</code></pre></div></div>
<p>This may look a litle strange at first, but it’s a highly convenient
feature once you get the hang of it. Another one is the use of ++ or –
to increase or reduce a property or variable by one. Thus intead of
writing <code class="language-plaintext highlighter-rouge">myNumber = myNumber + 1</code> or even
<code class="language-plaintext highlighter-rouge">myNumber+=1</code> one could write simply
<code class="language-plaintext highlighter-rouge">myNumber++</code>; likewise one could use
<code class="language-plaintext highlighter-rouge">myNumber-- </code>in place of
<code class="language-plaintext highlighter-rouge">myNumber = myNumber - 1</code>.</p>

<p>In these examples, <code class="language-plaintext highlighter-rouge">myNumber</code> could be either a
property or a variable. In TADS 3 programming properties tend to be used
for semi-permanent storage of information you need to be available to
the whole program, while variables are local in scope and temporary in
duration, used, for example, to hold the results of some intermediate
calculation (there are some library defined quanties of the form
<code class="language-plaintext highlighter-rouge">gWhatsit </code>that look like global variables, but
these are simply shorthand ways of referring to some commonly used
property of a library object). Being local in <em>scope</em> means that the
variable is available only to code within the same block (usually the
same method or function) as that in which the variable is defined; being
temporary in <em>duration</em> means that the variable only retains its value
for that particular invocation of the function or method. A variable
must be declared with the keyword <code class="language-plaintext highlighter-rouge">local</code> in the
block in which it appears, and may optionally be initialized in the same
statement in which it is initialized, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  local x;  local numberOfCabbageEaters = 12;
</code></pre></div></div>
<h3 id="d-referring-to-methods-and-properties">d. Referring to Methods and Properties</h3>

<p>Variables, and indeed statements, are generally used within object
methods and global functions. But how are the functions and methods used
in turn? Often the library will expect a method to be defined on an
object you create and will invoke (call) it under the appropriate
circumstances; moreover, you can often use a method in place of a
property when you want to do something more complex than you can do with
a property; then, when the library tries to (say) display the value of
the <code class="language-plaintext highlighter-rouge">name</code> property it may quite happily use the
value returned by the <code class="language-plaintext highlighter-rouge">name</code> method instead. If
you’ve defined a method <code class="language-plaintext highlighter-rouge">myMethod</code> on an object
<code class="language-plaintext highlighter-rouge">myObj</code> you can invoke it from anywhere in your
code by writing the statement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myObj.myMethod;
</code></pre></div></div>
<p>  or </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  myObj.myMethod(); 
</code></pre></div></div>
<p>Similarly, you can reference the value of the
<code class="language-plaintext highlighter-rouge">myProperty</code> property of
<code class="language-plaintext highlighter-rouge">myObj</code> with
<code class="language-plaintext highlighter-rouge">myObj.myProperty</code>. Note the use of the dot (.)
notation here, since you will be using it a lot.</p>

<p>In TADS 2 (or Inform 6), if you wanted to reference
<code class="language-plaintext highlighter-rouge">myObj.myMethod()</code> or
<code class="language-plaintext highlighter-rouge">myObj.myProperty</code> from another property or
method of <code class="language-plaintext highlighter-rouge">myObj</code> you would typically write
<code class="language-plaintext highlighter-rouge">self.myMethod()</code> or
<code class="language-plaintext highlighter-rouge">self.myProperty(), </code>where
<code class="language-plaintext highlighter-rouge">self</code> is a special keyword meaning “the current
object”. There are still situations where you may need to use the
<code class="language-plaintext highlighter-rouge">self</code> keyword in TADS 3 but this is no longer
one of them; instead, in this situation, you could write simply,
<code class="language-plaintext highlighter-rouge">myMethod()</code> or
<code class="language-plaintext highlighter-rouge">myProperty</code>. To make this clearer, we’ll give
an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myObj: Thing
    name = 'boring object'
    changeName
    {
        name = 'very boring object';
    }
    myName = ('my ' + name);myOtherObject: Thing
    name = 'exciting object'
    describeName
    {
        local dName = 'This is an ' + name + ', unlike ';

        myObj.changeName;

        dName += myObj.myName;

        say(dName);

        return dName;
    };
</code></pre></div></div>
<p>In this example, a call to
<code class="language-plaintext highlighter-rouge">myOtherObj.describeName</code> should result in the
display of the message “This is an exciting object, unlike my very
boring object”; moreover, if you wrote a statement such as
<code class="language-plaintext highlighter-rouge">msg = myOtherObj.describeName</code>, not only would
“This is an exciting object, unlike my very boring object” be displayed,
but the string ‘This is an exciting object, unlike my very boring
object’ would be stored in the variable <code class="language-plaintext highlighter-rouge">msg</code>.
This comes about because the last statement of
<code class="language-plaintext highlighter-rouge">describeName</code> tells the method to return a
value (in this case the value of the local variable
<code class="language-plaintext highlighter-rouge">dName</code>), and this value will be treated as the
value of the method if it is used in an expression.</p>

<h3 id="e-functions-and-methods">e. Functions and Methods</h3>

<p>Functions may return values in similar ways. The purpose of using a
function is typically to perform an often-used calculation that is not
related to any particular object, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function salesTax(salesValue, taxPercent){
return (salesValue * taxPercent)/100;}
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">function</code> keyword used here is optional but
perhaps makes the code clearer, although it is more usual to omit it in
TADS 3 code. Note that in this example, unless we’re using the
<code class="language-plaintext highlighter-rouge">BigNumber</code> class,
<code class="language-plaintext highlighter-rouge">salesValue</code> and
<code class="language-plaintext highlighter-rouge">taxPercent</code> must both be integers (e.g. 120
meaning, say, 120 pence or 120 cents, and 15 meaning 15%). More to the
point, note that <code class="language-plaintext highlighter-rouge">salesValue</code> and
<code class="language-plaintext highlighter-rouge">taxPercent</code> are the two formal parameters of
this function, which means that they’re placeholders for whatever values
we want to pass to the function when we call it. So, for example, if
from somewhere in the program we called
<code class="language-plaintext highlighter-rouge">taxPennies = salesTax(120, 15);</code>
<code class="language-plaintext highlighter-rouge">taxPennies</code> would be assigned the value 18.
Methods may also take parameters, so for example we could define:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myObj: Thing
baseName = 'object'
myName (qualifier)
{
  return 'my ' + qualifier + ' ' + baseName;
};
</code></pre></div></div>
<p>Note the use of extra string spaces so that
<code class="language-plaintext highlighter-rouge">myObj.myName('boring')</code> returns ‘my boring
object’ rather than ‘myboringobject’. Note also that we can also define
a method (or function) that takes no arguments by using an empty
argument list thus: (). So, for example, we could have defined:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myObj: Thing
    name = 'boring object'
    changeName()
    {

        name = 'very boring object';
    }
    myName = ('my ' + name);
</code></pre></div></div>
<p>And it would have meant precisely the same as the earlier definition
without the empty () after <code class="language-plaintext highlighter-rouge">changeName</code>. Which
you use is entirely up to you.</p>

<h3 id="f-conditions---if-statements">f. Conditions - If Statements</h3>

<p>Often one will want to use methods and functions to perform something a
bit more complex than we’ve shown here. One of the basic requirements of
any programming language is to be able to test for conditions and act
according to the results. For example, we might want
<code class="language-plaintext highlighter-rouge">myObj</code> to declare itself as either a boring
object or exciting object on the basis of a property used as a flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myObj : Thing   name   {
   if(exciting)

   return 'exciting object';
   else

   return 'boring object';   }
   exciting = nil
   myName = ('my ' + name);
</code></pre></div></div>
<p>The new construction introduced here means “if the condition in
parentheses following the keyword ‘if’ is true, carry out the statement
on the following line, otherwise carry out the statement following the
‘else’ keyword”. TADS 3 defines two special values,
<code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">nil </code>which
mean true and false (N.B., it’s <em>very</em> easy, especially if you’re used
to using another language, to type ‘false’ when you mean ‘nil’; TADS 3
uses <code class="language-plaintext highlighter-rouge">nil</code> since it has other uses beyond
Boolean false). Since the property <code class="language-plaintext highlighter-rouge">exciting</code>
contains <code class="language-plaintext highlighter-rouge">nil</code>
<code class="language-plaintext highlighter-rouge">myObj.name</code> will return ‘boring object’; if
<code class="language-plaintext highlighter-rouge">exciting</code> were later changed to
<code class="language-plaintext highlighter-rouge">true</code> (or to any non-zero number),
<code class="language-plaintext highlighter-rouge">myObj.name</code> would then return ‘exciting
object’.</p>

<p>The condition in an <code class="language-plaintext highlighter-rouge">if</code> statement can be much
more elaborate than the name of a property that evaluates to
<code class="language-plaintext highlighter-rouge">nil</code> or <code class="language-plaintext highlighter-rouge">true</code>. For
example, suppose that instead of a boolean
(<code class="language-plaintext highlighter-rouge">nil</code> or <code class="language-plaintext highlighter-rouge">true</code>)
<code class="language-plaintext highlighter-rouge">exciting</code> property we defined a numeric
<code class="language-plaintext highlighter-rouge">excitement</code> property, with the rule that the
object only becomes exciting if its <code class="language-plaintext highlighter-rouge">excitement</code>
property exceeds 10. We should then have written the test as
<code class="language-plaintext highlighter-rouge">if(excitement \&gt; 10)</code>. Alternatively, we might
have decided that the object value was only exciting if its excitement
value was exactly 123, in which case the condition would be written
<code class="language-plaintext highlighter-rouge">if(excitement == 123)</code>.</p>

<p>Note that this test for equality uses a <em>double equals sign</em> (==), and
must be written this way if this is what you mean. It’s very easy to
write something like <code class="language-plaintext highlighter-rouge">if(excitement = 123)</code> by
mistake, in which case the compiler will give you a warning, because it
almost certainly isn’t what you meant.</p>

<p>You may also want to combine tests using the logical operators <em>and</em>,
<em>or</em> and <em>not</em>, which in TADS 3 are defined with
<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">\|\|</code> and
<code class="language-plaintext highlighter-rouge">!</code> respectively. For example if we have defined
a <code class="language-plaintext highlighter-rouge">boring</code> property on
<code class="language-plaintext highlighter-rouge">myObj</code>, we might have wanted the exciting test
to be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if((!boring &amp;&amp; excitement &gt; 12) || excitement == 123)
</code></pre></div></div>
<p>This would mean, if <code class="language-plaintext highlighter-rouge">excitement</code> is equal to 123
or if it’s greater than 12 and <code class="language-plaintext highlighter-rouge">boring</code> is not
true. Note the use of grouping parentheses to resolve any potential
ambiguities in the order in which these conditions are evaluated.</p>

<p>There is no need to use the <code class="language-plaintext highlighter-rouge">else</code> clause at
all, if you don’t need it. But what happens if you need more than one
statement to be executed if something is true, and/or a whole set of
statements to be performed otherwise? In this case, we’d use braces
<code class="language-plaintext highlighter-rouge">{}</code> to group the statements, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if((!boring &amp;&amp; excitement &gt; 12) || excitement == 123){
myIndefiniteArticle = 'an';
return 'exciting object';}else{
myIndefiniteArticle = 'a';
return 'boring object';}
</code></pre></div></div>
<p>It’s quite common to want to assign one value to something if a
condition holds, and another otherwise, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(length &gt; 5)
size = 'big';else
size = 'small';
</code></pre></div></div>
<p>This is kind of thing is so common that TADS 3 provides a short-cut way
of doing it. Instead of writing the above, you could write simply:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size = (length &gt; 5) ? 'big' : 'small';
</code></pre></div></div>
<p>More generally this ternary operator works as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cond ? true-value  : false-value
</code></pre></div></div>
<p>If <code class="language-plaintext highlighter-rouge">cond</code> is true this evaluates to
<code class="language-plaintext highlighter-rouge">true-value</code>, otherwise it evaluates to
<code class="language-plaintext highlighter-rouge">false-value</code>.</p>

<h3 id="g-the-switch-statement">g. The Switch Statement</h3>

<p>It is possible to nest <code class="language-plaintext highlighter-rouge">if… else…</code> statements to
any required depth, so that one could, for example, have the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(excitement == 0)
    name = 'very boring object';else if (excitement == 1)
    name = 'boring object';else if (excitement == 2)
    name = 'moderately boring object';else if (excitement &lt; 5)
    name = 'vaguely boring object'else if(excitement &lt; 10)
    name = 'not too boring object';else
    name = 'exciting object'
    ;
</code></pre></div></div>
<p>But the trouble with this is that it can quickly become confusing to
keep track of which <code class="language-plaintext highlighter-rouge">else</code> is meant to match
which <code class="language-plaintext highlighter-rouge">if</code> (this can be alleviated by using
braces to group the code the way you want, though that can lead to
messy-looking and verbose code). In some cases this may be the only way
to achieve the effect you want, but in this particular case, where we
are simply testing the value of a single variable, it is often easier to
use a <em>switch</em> statement; in this case the equivalent switch statement
would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch(excitement)
    {case 0: name = 'very boring object'
     break
    case 1: name = 'boring object'
     break
    case 2: name = 'moderately boring object'
     break
    case 3:case 4: name = 'vaguely boring object'
     break
    case 5:case 6:case 7:case 8:case 9: name = 'not too boring object'
     break
    default: name = 'exciting object'
}
</code></pre></div></div>
<p>Note the use of the <code class="language-plaintext highlighter-rouge">break;</code> statements to stop
the test ‘falling through’ to other matches. Since we want the test to
fall through if <code class="language-plaintext highlighter-rouge">excitement</code> is 3, 5, 6, 7 or 8
we do not define a <code class="language-plaintext highlighter-rouge">break</code> statement for those
cases. So, for example, if <code class="language-plaintext highlighter-rouge">excitement</code> is 6 the
<code class="language-plaintext highlighter-rouge">switch</code> statement will execute the statements
for all the cases following <code class="language-plaintext highlighter-rouge">case 6</code> until it
encounters a <code class="language-plaintext highlighter-rouge">break</code>; this has the desired
effect of setting name to ‘not too boring object’. The
<code class="language-plaintext highlighter-rouge">default</code> case defines what happens if none of
the preceding cases is matched.</p>

<p>The <code class="language-plaintext highlighter-rouge">switch() </code>statement is not restricted to
matching numbers, it can also match (single-quoted) strings, objects,
lists, Boolean values (true or nil) or enumerators (which we’ll meet
again below). Again, the <code class="language-plaintext highlighter-rouge">case</code> value need not
be expressed as a constant of one of these types, so long as it is an
expression that evaluates to a constant value of one of these types.</p>

<h3 id="h-properties-containing-objects-and-lists">h. Properties Containing Objects and Lists</h3>

<p>This brings us to the final introductory point: so far our examples of
properties and variables have all been of ones that contain either
numbers, strings, or Boolean values (true or nil); but properties and
variables can also contain other data types such as objects, lists,
enumerators and function pointers, and although we shall be meeting few
enumerators and function pointers in what follows, properties containing
objects and lists will be rather more common. The concept of a property
or variable containing an object is really no more complicated than that
of having them refer to strings or numbers. For example if we had two
objects, <code class="language-plaintext highlighter-rouge">myObj1</code> and
<code class="language-plaintext highlighter-rouge">myObj2</code>, we could, say, use the assignment
statement <code class="language-plaintext highlighter-rouge">obj = myObj2</code> and then use obj to
refer to <code class="language-plaintext highlighter-rouge">myObj2</code>. This may seem a bit pointless
at first, but it could be useful if we didn’t know in advance which
object obj was going to be, and we wanted to write general code that
could work equally well with a number of objects. To take a trivial
example, suppose we wrote the following function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function showName(obj){
    say(obj.name);
    }
</code></pre></div></div>
<p>This definition would then allow us to call
<code class="language-plaintext highlighter-rouge">showName(myObj1)</code> to display
<code class="language-plaintext highlighter-rouge">myObj1.name</code>,
<code class="language-plaintext highlighter-rouge">showName(myObj2)</code> to display
<code class="language-plaintext highlighter-rouge">myObj2.name</code> and so on. This example is so
trivial that it may still seem pointless, but even in a slightly more
complex case the value may start to become apparent:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function talkAbout(obj){
    local msg = 'My '
    msg += obj.name
    msg += ' is really very '
    if(obj.excitement &lt; 10)       msg += 'dull.'
    else      msg += 'interesting.'
    say(msg)
}
</code></pre></div></div>
<p>Perhaps an even more common use of assigning objects to properties is
where other objects need to keep track of them. For example, if I have
an object (say ‘ball’) inside another object (‘bag’), then the
<code class="language-plaintext highlighter-rouge">location</code> property of the ball can keep track
of where the ball is by being set to the bag object. If the ball is then
moved to the tennis court the <code class="language-plaintext highlighter-rouge">location</code>
property of the ball object could be set to the
<code class="language-plaintext highlighter-rouge">tennisCourt</code> object to keep track of it.</p>

<p>At first sight, it may seem that doing it the other way round wouldn’t
work so well, since, say, using <code class="language-plaintext highlighter-rouge">bag.contents</code>
to keep track of what’s in the bag would only allow one object to be in
the bag at the time. In fact this is an example of where one would use a
<code class="language-plaintext highlighter-rouge">list</code> value. A list is basically a list of
items (of any of the valid types, including other lists) enclosed in
square brackets and separated by commas, e.g.:</p>

<p>bag.contents = [ball, coin, banana, horseshoe]</p>

<p>To find out whether something’s in a list one can use its
<code class="language-plaintext highlighter-rouge">indexOf</code> method; e.g.
<code class="language-plaintext highlighter-rouge">bag.contents.indexOf(ball)</code> would be 1;
<code class="language-plaintext highlighter-rouge">bag.contents.indexOf(banana)</code> would be 3, and
<code class="language-plaintext highlighter-rouge">bag.contents.indexOf(elixirOfLife) </code>would be
nil.</p>

<h3 id="i-nested-objects">i. Nested Objects</h3>

<p>The previous section only scratches the surface of TADS 3 lists; to find
out more, look up lists in the <em>System Manual</em> that comes with the TADS
3 Author’s Kit. We’ll conclude with a rather different kind of list to
illustrate one last point, the use of nested objects in TADS 3.</p>

<p>Suppose we have a ball that appears to change colour randomly when we
look at it. We might define it like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ball: Thing 'ball' 'ball'
"When you look at it, it looks &lt;&lt;colour&gt;&gt;. "
 colour  { return colourList.getNextValue(); };colourList: ShuffledList
valueList = ['red', 'green', 'blue', 'violet', 'white',

'black', 'orange', 'indigo'];
</code></pre></div></div>
<p>The purpose of a <code class="language-plaintext highlighter-rouge">ShuffledList</code> is to return one
of its values randomly, without repeating a value until it has used them
all. It’s a bit like shuffling a pack of cards, then taking one in turn
until all have been used, then reshuffling the pack and starting again.
But in order to function this way a
<code class="language-plaintext highlighter-rouge">ShuffledList</code> needs to be a separate object,
not only with a list of values (its <code class="language-plaintext highlighter-rouge">valueList</code>
property) but also a method (<code class="language-plaintext highlighter-rouge">getNextValue</code>)
that returns the next shuffled value. In order to define the
varicoloured ball object, therefore, we also need to define a separate
<code class="language-plaintext highlighter-rouge">colourList</code> object. While this is far from
catastrophic, it can be a little inconvenient, since code that helps to
define the behaviour of one object is spread into another; the two
objects might in time get separated in your code, or the presence of the
second object might mess up the containment hierarchy in some way. This
is where a nested object could come in handy.</p>

<p>As an intermediary step, note that a property can contain a reference to
an object; for example, we could have written:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ball: Thing 'ball' 'ball'
"When you look at it, it looks &lt;&lt;colour&gt;&gt;. "
 colour  { return colourList.getNextValue(); }
 colourList = colourListObj;colourListObj: ShuffledList
valueList = ['red', 'green', 'blue', 'violet', 'white',

'black', 'orange', 'indigo'];
</code></pre></div></div>
<p>And this would work just the same (although it appears a little more
verbose). The <code class="language-plaintext highlighter-rouge">colour</code> method now refers to the
<code class="language-plaintext highlighter-rouge">colourList</code> property which in turn refers to
the <code class="language-plaintext highlighter-rouge">colourListObj</code> object. The way we could
make this more compact is to turn the
<code class="language-plaintext highlighter-rouge">colourListObj</code> object into an anonymous object
defined directly on the <code class="language-plaintext highlighter-rouge">colourList</code> property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ball: Thing 'ball' 'ball'
    "When you look at it, it looks &lt;&lt;colour&gt;&gt;. "
     colour  { return colourList.getNextValue(); }
     colourList: ShuffledList
     {
        valueList = ['red', 'green', 'blue', 'violet', 'white',

    'black', 'orange', 'indigo']
     };
</code></pre></div></div>
<p>Not only is this more concise, but it has the advantage of keeping all
the code together in one object. The
<code class="language-plaintext highlighter-rouge">ShuffledList</code> has now become an <em>anonymous
nested object</em>. All nested objects are anonymous, because they have no
name: <code class="language-plaintext highlighter-rouge">colourList</code> is not the name of the
<code class="language-plaintext highlighter-rouge">ShuffledList</code> object here, it’s the name of a
property of <code class="language-plaintext highlighter-rouge">ball</code>; the
<code class="language-plaintext highlighter-rouge">ShuffledList</code> can nevertheless be referred to
as <code class="language-plaintext highlighter-rouge">ball.colourList</code>, since it is the value of
<code class="language-plaintext highlighter-rouge">ball</code>’s <code class="language-plaintext highlighter-rouge">colourList</code>
property. Note that while an ordinary object definition may either be
terminated with a semicolon or enclosed in braces, the braces
(<code class="language-plaintext highlighter-rouge">{}</code>) form must <em>always</em> be used with a nested
object, as here.</p>

<p>This may seem a bit strange and convoluted at first, but you’ll find the
use of anonymous nested objects is a powerful and common feature of TADS
3 programming, so it will be as well to become familiar with it.<br />
   <br />
————————————————————————</p>

<p><em>Getting Started in TADS 3</em><br />
<a href="index.html">[Main]</a><br />
<em><a href="creatingyourfirsttads3project.html">[Previous]</a>
  <a href="furtherprogramming.html">[Next]</a></em></p>


</main>
<footer>
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>