<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title></title>
    <meta property="og:title" content=
    "">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header id="header"><div class="header-search">
    <form class="header-search-form" action="/search" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<p><img src="topbar.jpg" data-border="0" />
<a href="toc.html" class="nav">Table of Contents</a> |
<a href="langsec.html" class="nav">The Language</a> &gt; Procedural Code<br />
<span class="navnp"><a href="expr.html" class="nav"><em>Prev:</em> Expressions and
Operators</a>    
<a href="optparams.html" class="nav"><em>Next:</em> Optional
Parameters</a>     </span></p>
<h1 id="procedural-code">Procedural Code</h1>

<p>TADS 3 lets you do a lot “declaratively,” meaning that you just define
objects, their attributes, and their relationships to one another, and
the system and library take care of the details of running the game.
That’s great as far as it goes, but no one has ever developed a system
that can do <em>everything</em> declaratively (though some have tried). For the
things you can’t do declaratively, TADS 3 provides a powerful
“procedural” language, which lets you write step-by-step instructions
for the computer to follow.</p>

<h2 id="quick-index">Quick index</h2>

<ul>
  <li><a href="#functionsAndMethods">Functions and methods</a>
    <ul>
      <li><a href="#funcdef">Defining a function</a></li>
      <li><a href="#optArgs">Optional arguments</a></li>
      <li><a href="#namedArgs">Named arguments</a></li>
      <li><a href="#funcModRep">Replacing or modifying a function</a></li>
      <li><a href="#methdef">Defining a method</a></li>
      <li><a href="#shortMeth">Short-hand method definitions</a></li>
      <li><a href="#floatingMethods">Floating methods</a></li>
      <li><a href="#varargs">Varying argument lists</a></li>
      <li><a href="#varargsCall">Varying-argument calls</a></li>
    </ul>
  </li>
  <li><a href="#externDecl">External declarations</a></li>
  <li><a href="#propdecl">Property name declarations</a></li>
  <li><a href="#statement">Procedural statements</a>
    <ul>
      <li><a href="#blocks">Code blocks</a></li>
      <li><a href="#labels">Statement labels</a></li>
      <li><a href="#emptystm">Empty statements</a></li>
      <li><a href="#local">Local variable declarations</a></li>
      <li><a href="#exprstm">Expression statements</a></li>
      <li><a href="#dqstm">Double-quoted string statement</a></li>
      <li><a href="#return">return</a></li>
      <li><a href="#if">if</a></li>
      <li><a href="#for">for</a>
        <ul>
          <li><a href="#cfor">C-style <code class="language-plaintext highlighter-rouge">for</code> loops</a></li>
          <li><a href="#forIn">for..in</a></li>
          <li><a href="#forInRange">for..in range</a></li>
          <li><a href="#combinedFor">Combining the <code class="language-plaintext highlighter-rouge">for</code> syntax
types</a></li>
        </ul>
      </li>
      <li><a href="#foreach">foreach</a></li>
      <li><a href="#while">while</a></li>
      <li><a href="#dowhile">do…while</a></li>
      <li><a href="#switch">switch</a>
        <ul>
          <li><a href="#caseBreaks"><code class="language-plaintext highlighter-rouge">break</code> must be explicit</a></li>
          <li><a href="#indentStyle"><code class="language-plaintext highlighter-rouge">switch</code> indentation
styles</a></li>
        </ul>
      </li>
      <li><a href="#goto">goto</a></li>
      <li><a href="#break">break</a></li>
      <li><a href="#continue">continue</a></li>
      <li><a href="#throw">throw</a></li>
      <li><a href="#try">try</a></li>
    </ul>
  </li>
  <li><a href="#tads2">Notes for TADS 2 users</a></li>
</ul>

<h2 id="functions-and-methods"><span id="functionsAndMethods">Functions and methods</span></h2>

<p>There are two places where procedural code can appear. The first is in
“functions,” and the second is in “methods.”</p>

<p>A function is a body of procedural instructions that’s all grouped up
and given a name. Functions are so named because they resemble in form
what mathematicians call functions: a function takes a set of input
values, which we call parameters, and produces an output value as its
result. For example, in mathematics, the “square root” function takes a
number as its argument, and yields the square root of the number as its
result. Now, in mathematics, there are other requirements that must be
met before you can truly call something a function, but for our purposes
a function is this just basic “black box” that takes a set of inputs and
produces a result value.</p>

<p>A method is almost the same as a function, but has the additional
quality that it’s associated with a particular object or class. This
grouping of procedural code as part of an object is a defining feature
of Object-Oriented Programming. It’s proved to be a very useful
organizational tool, because it encourages programmers to think about
how a problem breaks down into data structures, and then provides a way
to group each data structure with the parts of the code that operate on
it.</p>

<h3 id="defining-a-function"><span id="funcdef">Defining a function</span></h3>

<p>A function definition has this form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functionName ( [ paramName [ , paramName ... ]  ]  )
{
   functionBody
}
</code></pre></div></div>

<p>Note that the parentheses for the parameter list are always required. If
you want to define a function that doesn’t take any parameters, just use
empty parentheses after the function name.</p>

<p>The parameter names act like local variables defined just inside the
function body’s open-brace. This means that you can’t define a local
variable with the same name in the function’s outermost code block.
(It’s legal to reuse a parameter’s name for a local within a nested
block, though, for the same reason you can define a new local in a
nested block with the same name as a local in an outer block.)</p>

<p>The function body consists of a series of procedural statements. When
the function is invoked, the VM starts at the first (topmost) procedural
statement in the function body, and proceeds through them sequentially
until the function returns to its caller via an explicit
<code class="language-plaintext highlighter-rouge">return</code> statement, throws an error, or “falls
off the end” (that is, the sequential execution point reaches the
function body’s closing brace). Falling off the end is equivalent to
returning <code class="language-plaintext highlighter-rouge">nil</code>, so it’s as though there were a
<code class="language-plaintext highlighter-rouge">return nil;</code> statement just before the function
body’s closing brace.</p>

<p>A function definition can only appear in “top-level” code - that is,
outside of any object, class, or function definition. If you use this
syntax within an object or class definition, the compiler will think you
want to define a method.</p>

<p>Function names are global. A symbol that’s used as the name of a
function cannot be used to name anything else with global scope (such as
properties, objects, classes, enums).</p>

<p>To call a function, you write the function name followed by its
arguments, enclosed in parentheses. This syntax constitutes a
<em>function-call expression</em>, and you can use it anywhere an expression
can go, including within a larger expression.</p>

<p>For example, here’s a complete program that defines two functions:
<code class="language-plaintext highlighter-rouge">main()</code>, which is the main entrypoint function
that every program must provide, and <code class="language-plaintext highlighter-rouge">cube()</code>,
which raises a given number to the third power and returns the result.
The <code class="language-plaintext highlighter-rouge">main()</code> function uses
<code class="language-plaintext highlighter-rouge">cube()</code> to calculate a few cubed values,
displays them, and exits.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #include "tads.h"

    main(args)
    {
      local c1 = cube(1), c2 = cube(2), c3 = cube(3);
      local cc3 = cube(c3);

      "1 cubed = &lt;&lt;c1&gt;&gt;, 2 cubed = &lt;&lt;c2&gt;&gt;, 3 cubed = &lt;&lt;c3&gt;&gt;\n";
      "3 cubed cubed &lt;&lt;cc3&gt;&gt;\n";
    }

    cube(n)
    {
      return n * n * n;
    }
</code></pre></div></div>

<h3 id="optional-arguments"><span id="optArgs">Optional arguments</span></h3>

<p>In some cases, it’s convenient to be able to declare a function or
method parameter as optional. This means that a caller can provide an
argument value for the parameter, but doesn’t have to: a caller can
simply omit the argument entirely if it wants to use the default value
for the parameter.</p>

<p>The syntax for optional parameters is simple. Just place a
“<code class="language-plaintext highlighter-rouge">?</code>” after the name of a parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    stringToInt(str, radix?)
    {
      // ...
    }
</code></pre></div></div>

<p>This lets callers call the function with or without the “radix”
parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = stringToInt('12345');
    y = stringToInt('3F7A', 16);
</code></pre></div></div>

<p>When only one argument is supplied, it’s assigned to “str”, because that
parameter is required, and the optional “radix” parameter is set to the
default value <code class="language-plaintext highlighter-rouge">nil</code>. When two arguments are
supplied, the first is assigned to “str” and the second to “radix”.</p>

<p>For this particular example, it would be even better to be able to
define a specific default value for the “radix” argument. Fortunately,
there’s syntax for this: rather than using the
“<code class="language-plaintext highlighter-rouge">?</code>” suffix, instead write
“<code class="language-plaintext highlighter-rouge">=</code> <em>expression</em>”, where <em>expression</em> gives the
default value to be applied:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    stringToInt(str, radix = 10)
    {
      // ...
    }
</code></pre></div></div>

<p>This says that the “radix” parameter should be set to 10 whenever a
caller doesn’t supply a second argument value. When the caller <em>does</em>
provide two arguments, the caller’s value overrides the default value.</p>

<p>For more information, including a couple of subtleties that are worth
knowing about, see the <a href="optparams.html">optional parameters section</a>.</p>

<h3 id="named-arguments"><span id="namedArgs">Named arguments</span></h3>

<p>The usual way of passing arguments, as described above, is
<strong>positional</strong>: the first value listed in the caller’s argument list is
assigned to the first variable name in the callee’s parameter list, the
caller’s second value goes to the callee’s second parameter name, and so
on.</p>

<p>There’s another way, which we call <strong>named arguments</strong>. Instead of
assigning values to parameter names by position, the caller actually
specifies the name to use for each value. The values are then assigned
to variables with the same names in the callee, regardless of the order
of the values.</p>

<p>The caller and callee <strong>both</strong> have to agree on this protocol. When
defining a function, you specify that it takes named argument values by
putting a colon after each parameter name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    diff(a:, b:)
    {
       return a - b;
    }
</code></pre></div></div>

<p>The caller invokes this function with similar syntax: for each named
parameter, we must write the name, a colon, and then the value to use
for that parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = diff(a: 5, b: 3);
</code></pre></div></div>

<p>Because the parameters are named, the caller can list them in a
different order from the callee. So we can rewrite the call above as
follows, and we’ll get exactly the same result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = diff(b: 3, a: 5);
</code></pre></div></div>

<p>You can freely mix positional and named parameters in the same function
definition. Parameters with the colon suffix will be named, and those
without will be positional. The caller must specify the positional
parameters in the same order as in the function definition, but the
named parameters can be mixed into the list in any order.</p>

<p>For full details on named parameters and why (and when) you’d want to
use them, see the <a href="namedargs.html">named arguments chapter</a>.</p>

<h3 id="replacing-or-modifying-a-function"><span id="funcModRep">Replacing or modifying a function</span></h3>

<p>When using a library, it’s sometimes useful to be able to replace a
function that the library provides with your own definition. The
<code class="language-plaintext highlighter-rouge">replace</code> keyword lets you do this. To use this
feature, just write <code class="language-plaintext highlighter-rouge">replace</code> in front of your
function definition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    replace someFunc(a, b)
    {
       // new code for the function...
    }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">replace</code> completely discards the original
library definition of the function, and replaces it with your new
definition; it’s as though the library version were never defined.</p>

<p>Sometimes you want to augment a library function rather than replace it
entirely. For example, you might want to add some special-case handling
for one or two particular parameter values, but fall back on the
original library definition for everything else. In these cases, you can
“modify” a function. This replaces the original function with your new
version, but it also keeps the original function around; the old
function loses the right to use the name, but its code is still present.
Whenever any code calls the function by name, your new version will be
invoked.</p>

<p>To reach the original version of the function, you use a special
keyword, <code class="language-plaintext highlighter-rouge">replaced</code>, within your new version of
the function. This is the only place where
<code class="language-plaintext highlighter-rouge">replaced</code> works - you can only reach the old
function from within your new version.
<code class="language-plaintext highlighter-rouge">replaced</code> looks syntactically like a function
call: you write, for example, <code class="language-plaintext highlighter-rouge">replaced(7, 'a')</code>
to invoke the original function.</p>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    getName(val)
    {
      switch(dataType(val))
      {
      case TypeObject:
        return val.name;

      default:
        return 'unknown';
      }
    }

    modify getName(val)
    {
      if (dataType(val) == TypeSString)
        return '\'' + val + '\'';
      else
        return replaced(val);
    }
</code></pre></div></div>

<p>Note how the modified function refers back to the original version: we
add handling for string values, which the original definition didn’t
provide, but simply invoke the original version of the function for any
other type. The call to <code class="language-plaintext highlighter-rouge">replaced(val)</code> invokes
the previous definition of the function, which we’re replacing.</p>

<p>Once a function is redefined using modify, it’s no longer possible to
invoke the old definition of the function directly by name. The only way
to reach the old definition is via the
<code class="language-plaintext highlighter-rouge">replaced</code> keyword, and that can only be used
within the new definition of the function. However, note that you can
obtain a pointer to the old function, and then invoke the old function
through that pointer outside the bounds of the redefinition. To get the
pointer, use the <code class="language-plaintext highlighter-rouge">replaced</code> keyword without an
argument list.</p>

<h3 id="defining-a-method"><span id="methdef">Defining a method</span></h3>

<p>A method definition looks just like a function definition syntactically.
The only difference is the placement within the source code. Whereas a
function is declared at the top level of the program, outside of all
objects, a method is declared within an object. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    class MyClass: object
      getOwner()
      {
        // code goes here...
      }
    ;
</code></pre></div></div>

<p>In most respects, a method acts very much like a function. The
difference is that a method is associated with the class or object in
which it’s defined. The method can only be invoked through the defining
object or class, or it can be reached by “inheritance” - that is,
through a descendant in the class hierarchy (that is, a subclass of this
object or class, a subclass of a subclass, etc., or an instance of the
class). To call a method, then, you have to name not only the method
itself but also the object it’s associated with. You do that with the
“dot” operator (<code class="language-plaintext highlighter-rouge">.</code>), like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = MyClass.getOwner();
</code></pre></div></div>

<p>Within the method, you can use the <code class="language-plaintext highlighter-rouge">self</code>
pseudo-variable to determine which object was used to invoke the method.
Now, it might seem that this information is redundant, since the method
is by its very nature already associated with a particular object or
class. But as we just mentioned, you can reach the method through the
defining object/class <em>or</em> through a subclass or instance of the
defining object. For example, consider this code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = new MyClass();
    local y = x.getOwner();
</code></pre></div></div>

<p>This creates an instance of the class, then calls the method on the
instance object, not on the class itself. If you looked at
<code class="language-plaintext highlighter-rouge">self</code> within the method in this case, it would
contain the instance object, not MyClass itself.</p>

<p>One of the key principles behind object-oriented programming is that
code related to an object should be grouped with the object, by defining
the code using methods. So one thing you tend to see a lot of in
well-designed OO code is one method of an object calling another method
of the same object. In other words, you tend to see a lot of
<code class="language-plaintext highlighter-rouge">self.xxx()</code> calls within method code. This is
so common that TADS 3 has a convenient short-hand notation for just this
case: when calling a method or property of
<code class="language-plaintext highlighter-rouge">self</code> within a method, you can omit the
<code class="language-plaintext highlighter-rouge">self.</code> prefix entirely, and just write the
method call as though it were a function call. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    class MyClass
      isOwned()
      {
        // check some conditions, and return true or nil...
      }
      getOwner()
      {
        if (isOwned())
          // do something...
      }
    ;
</code></pre></div></div>

<p>In this example, the call to <code class="language-plaintext highlighter-rouge">isOwned()</code> within
<code class="language-plaintext highlighter-rouge">getOwner()</code> is <em>not</em> a function call, even
though it looks like one at first glance. Rather, it’s a method call,
and behaves exactly as though we’d written
<code class="language-plaintext highlighter-rouge">self.isOwned()</code>.</p>

<h3 id="short-hand-method-definitions"><span id="shortMeth">Short-hand method definitions</span></h3>

<p>In addition to the standard function-like syntax for defining a method,
there are a couple of short-hand formats that are more convenient for
simple methods.</p>

<p>First, if a method take no parameters, you can omit the parameter list.
This is especially handy for one-liner methods, where the whole body of
the method fits on one line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    class MyClass
      getOwner { // etc }
    ;
</code></pre></div></div>

<p>Second, if a method takes no parameters, and the only thing it does is
evaluate an expression and return the result, you can write the method
almost as though it were a property definition, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    class MyClass
      getOwner = (myOwner != nil ? myOwner.actualOwner(self) : nil)
</code></pre></div></div>

<p>That has exactly the same meaning as if
<code class="language-plaintext highlighter-rouge">getOwner()</code> had been defined like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      getOwner()
      {
        return myOwner != nil ? myOwner.actualOwner(self) : nil;
      }
</code></pre></div></div>

<p>These short-hand formats are syntactic variations only - they don’t make
any difference in the behavior, size, or speed of the generated code.
The short-hand syntax might make your <em>source</em> code look smaller, but it
won’t make your <em>compiled</em> code any smaller or any faster, because the
compiler generates the same byte-code in any case. These syntax
variations are for your coding convenience; they’re not performance
optimizations.</p>

<h3 id="floating-methods"><span id="floatingMethods">Floating methods</span></h3>

<p>Another way of defining a method is to define it <em>without</em> an associated
object definition. This is called a “floating” method, since it’s not
attached to any object definition.</p>

<p>The syntax for a floating method is almost the same as for a function.
The only difference is that you substitute the keyword
<code class="language-plaintext highlighter-rouge">method</code> for <code class="language-plaintext highlighter-rouge">function</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    method getTopLoc()
    {
       return location == nil ? self : location;
    }
</code></pre></div></div>

<p>Even though this looks like a function, you can use
<code class="language-plaintext highlighter-rouge">self</code>, and access properties of
<code class="language-plaintext highlighter-rouge">self</code> (such as
<code class="language-plaintext highlighter-rouge">location</code>, in this example). You can also
access all of the other method context pseudo-variables
(<code class="language-plaintext highlighter-rouge">definingobj</code>,
<code class="language-plaintext highlighter-rouge">targetobj</code>, and
<code class="language-plaintext highlighter-rouge">targetprop</code>), and you can use
<code class="language-plaintext highlighter-rouge">inherited</code> and
<code class="language-plaintext highlighter-rouge">delegated</code>. None of these things are allowed in
an ordinary function, since there’s no method context in an ordinary
function.</p>

<p>A floating method actually <em>is</em> a function. If you look at
<code class="language-plaintext highlighter-rouge">dataType(getTopLoc)</code>, you’ll see that it’s
<code class="language-plaintext highlighter-rouge">TypeFuncPtr</code>. You <em>can</em> call it like a regular
function, without an object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local t = getTopLoc();
</code></pre></div></div>

<p>However, if the method accesses <code class="language-plaintext highlighter-rouge">self</code> or other
method context variables, calling it this way will cause a run-time
error. That’s what would happen in our example, since it references a
property of <code class="language-plaintext highlighter-rouge">self</code>. The problem is that a
function call doesn’t have a method context, so references to method
context variables won’t work the way they do when a method is running.</p>

<p>So if it’s not really callable as a function, and it’s not callable as a
method because it’s not associated with any object, what exactly is it
good for? The answer, of course, is adoption.</p>

<p>Floating methods are intended to be associated with objects
<em>eventually</em>, even though they’re not initially. Their purpose is to let
you define a method that’s not <em>initially</em> attached to any object, but
only so that you can attach it dynamically, at run-time, as an actual
method of one or more objects. You do this using
<code class="language-plaintext highlighter-rouge">TadsObject.setMethod()</code>, which you can find
more about <a href="tadsobj.html#setMethod">here</a>.</p>

<h3 id="varying-argument-lists"><span id="varargs">Varying argument lists</span></h3>

<p>A function or method can be defined as taking a varying number of
parameters. That is, rather than specifying an exact number of arguments
that the caller must supply, you can define the function or method so
that it lets the <em>caller</em> decide how many arguments to supply; the
function or method determines how many were actually passed at run-time.
(This is sometimes called a “varargs” function, for “varying
arguments.”) To define this type of function or method, you use an
ellipsis, <code class="language-plaintext highlighter-rouge">...</code>, in place of the last parameter
name. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    printf(fmt, ...) { }
    {
      // code goes here...
    }
</code></pre></div></div>

<p>When you define a function/method that takes varying parameters, callers
must supply <em>at least</em> the named parameters, and may then supply any
number (including zero) of additional arguments. The first argument
value (starting at the left) that the caller supplies is assigned to the
first named parameter in the function’s or methods’ parameter list, the
second argument value is assigned to the second named parameter, and so
on. You can retrieve the unnamed extra parameters using the
<code class="language-plaintext highlighter-rouge">getArg()</code> intrinsic function, and you can
determine the total number of arguments using the
<code class="language-plaintext highlighter-rouge">argcount</code> pseudo-variable.
<code class="language-plaintext highlighter-rouge">getArg(n)</code> returns the <em>n</em>th argument value,
where <em>n</em> ranges from 1 to <code class="language-plaintext highlighter-rouge">argcount</code>.</p>

<p>It’s equally valid to use an ellipsis as the <em>entire</em> parameter list, if
you want to accept zero or more arguments:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    printStuff(...)
    {
      // code goes here...
    }
</code></pre></div></div>

<p>Since there are no named arguments, the caller doesn’t have to supply
any arguments at all, and you must access all of the arguments via
<code class="language-plaintext highlighter-rouge">getArg()</code>.</p>

<p>You can alternatively give the varying part of the parameter list a
name, indicating to the compiler that you want the extra arguments to be
bundled up into a list and made accessible as a local variable. To do
this, replace the ellispis (<code class="language-plaintext highlighter-rouge">...</code>) with a
parameter name, but enclose the parameter name in square brackets:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    printf(fmt, [lst])
    {
       foreach (local x in lst)
         // do something...
    }
</code></pre></div></div>

<p>This is exactly like the earlier <code class="language-plaintext highlighter-rouge">printf(fmt,
...)</code> declaration, but it creates a list from the extra parameters
and stores it in the local variable <code class="language-plaintext highlighter-rouge">lst</code>.</p>

<p>The “varying list” syntax is essentially equivalent functionally to the
ellipsis syntax, but many people find it cleaner-looking and easier to
use, since it lets you operate on the varying arguments using the
language’s standard list features. However, note that it’s slightly less
efficient, because the VM has to go to a little extra trouble to create
the list for you. For most functions and methods, the cleaner and easier
coding is well worth the slight performance cost; but for a
performance-critical function (one that’s called very frequently, for
example), you might get better execution speed with the ellipsis style.</p>

<h3 id="varying-argument-calls"><span id="varargsCall">Varying-argument calls</span></h3>

<p>In addition to being able to <em>receive</em> varying arguments as a list, you
can <em>send</em> a list value to a function or method, as though the list were
a series of individual argument values. To do this, place an ellipsis
after the list argument value in the function or method call’s argument
list:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local lst = [1, 2, 3];
    formatStr('x[%d, %d] = %d', lst...);
</code></pre></div></div>

<p>Rather than passing two arguments to
<code class="language-plaintext highlighter-rouge">formatStr()</code> (i.e., a string and a four-element
list), this passes four arguments (a string, the integer 1, the integer
2, and the integer 3), as though all four had been passed as separate
arguments - in other words, the call is identical to this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    formatStr('x[%d, %d] = %d', 1, 2, 3);
</code></pre></div></div>

<p>This notation allows you to call a function that takes a variable
argument list, using a list to provide the varying argument values. This
makes it possible to layer calls to functions and methods with variable
argument lists, since an intermediate function can itself take a
variable argument list and later pass the same arguments to another
variable argument function.</p>

<h2 id="external-declarations"><span id="externDecl">External declarations</span></h2>

<p>When you build your program, the compiler scans all of the source files
in your project for symbol names before it does anything else. This
means that you can define a function or an object in one source file,
and freely refer to it from another source file; and similarly, you can
freely refer to functions and objects that are not defined until later
in the same source file. The compiler’s pre-scan of the entire source
ensures that it knows how symbols are used throughout the program. This
eliminates most of the “external” and “forward” declaration overhead
that many other programming languages force you to use.</p>

<p>In a few rare cases, though, you might actually need to explicitly
define external symbols. This happens only when you’re compiling part of
a program in isolation, and won’t combine the compiled object files with
the rest of the program until later. The most likely situation where
this would happen is in creating a library, where you want to distribute
the library in compiled form rather than as source files.</p>

<p>To define a function or object as external, you use the
<code class="language-plaintext highlighter-rouge">extern</code> statement. This statement can be used
to define functions, objects, and classes. The syntax is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern function functionName ( [ param [ , param ... ]  ]  ) ;
extern object objectName ;
extern class className ;
</code></pre></div></div>

<p>These statements must be placed in “top level” code, outside of all
object or function definitions.</p>

<h2 id="property-name-declarations"><span id="propdecl">Property name declarations</span></h2>

<p>For the most part, the compiler automatically determines the type of
each symbol used throughout the program - object name, function name,
class name, property name, enum, etc. The compiler recognizes a symbol
as a property name when the symbol is used to define a property or
method of an object:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    class MyClass: object
       name = 'my class'
       weight = 10
       getOwner() { return owner; }
    ;
</code></pre></div></div>

<p>The compiler will automatically infer from this code that
<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">weight</code>, and
<code class="language-plaintext highlighter-rouge">getOwner()</code> are property names, since they’re
used to explicitly define properties and methods of MyClass.</p>

<p>In some cases, you won’t have occasion to define a value for a
particular property as part of an object definition anywhere in the
program, but you still want to use the name as a property name. For
these situations, the compiler lets you explicitly declare a symbol as
being a property name. The syntax is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>property propName [ , propName ... ]  ;
</code></pre></div></div>

<p>This statement declares each listed symbol as a property. It must be
placed in “top level” code, outside of all object or function
definitions.</p>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    property name, weight, getOwner;
</code></pre></div></div>

<p>Note that you can define method names as well as property names. A
method name is identical to a property name in terms of the symbol type,
so there’s no difference in the declaration syntax.</p>

<h2 id="procedural-statements"><span id="statements">Procedural statements</span></h2>

<p>Within a function or method body, you can write a series of procedural
steps, called “statements.” A procedural statement is a single program
instruction.</p>

<p>Every statement starts with a “keyword” that indicates what action
should be carried out when the statement is executed. Actually, make
that <em>almost</em> every statement; there are a couple of exceptions. An
“expression” statement simply consists of an expression to evaluate,
with no introductory keyword. Also, there’s such a thing as an “empty”
statement, which contains nothing at all except for the final semicolon
that all statements require. (An empty statement does nothing at all -
which sounds useless, but it actually is useful in some cases as a
placeholder, to fill in a spot that syntactically requires a statement
but for which you have no actual work to do.)</p>

<p>Most statements have some extra information after the keyword, giving
the specifics about what to do in the course of carrying out the
statement.</p>

<p>All statements end with a semicolon (<code class="language-plaintext highlighter-rouge">;</code>).</p>

<p>The interpreter carries out a function or method by executing its
statements, one at a time, starting at the first. In the simplest case,
execution steps sequentially through the statements in the function
until reaching the last one. Usually, though, it’s not quite this
simple, because some statements “jump” to another point in the function.
The <code class="language-plaintext highlighter-rouge">if</code> statement, for example, jumps to one
point if a given condition is true, and a different point if the
condition is false. The <code class="language-plaintext highlighter-rouge">for</code> statement sets up
a loop, where a group of statements is repeatedly executed as long as a
condition is true.</p>

<h3 id="code-blocks"><span id="blocks">Code blocks</span></h3>

<p>A “code block” is a group of statements enclosed in braces
(<code class="language-plaintext highlighter-rouge">{ }</code>). Code blocks are important for two
reasons:</p>

<p>First, grouping statements with braces turns the group into what’s
effectively a single statement. In almost any place where a single
statement is required, you can substitute a code block for the single
statement. This is how you write a <code class="language-plaintext highlighter-rouge">for</code> loop
with several statements in the loop body, for example.</p>

<p>A group of statements enclosed in braces acts syntactically like a
complete statement - <em>including</em> the obligatory semicolon that ends
every statement. That means that when you use a brace group in a slot
designed for a single statement, you <strong>must not</strong> add a semicolon after
the closing brace. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // WRONG!!!  The extra semicolon is redundant
    if (x == 1)
      { someFunc(1); };

    // Right
    if (x == 1)
      { someFunc(1); }
</code></pre></div></div>

<p>Second, code blocks define the “scope” of local variables. A local
variable defined within a given code block exists only within that
block - that is, only as far as the next closing brace, not counting the
closing braces of nested code blocks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    myFunc(x)
    {
      local a;

      if (x == 1)
      {
        local b;

        // local a is still valid here, since we're only nested -
        // symbols in scope within a given code block are in scope
        // within any blocks nested within
      }
      // local b is now out of scope, since we've ended the code
      // block where it was defined

      // local a is still in scope, of course, since we're still in
      // its code block
    }
    // now local a is out of scope, too, since we've ended its block
</code></pre></div></div>

<h3 id="statement-labels"><span id="labels">Statement labels</span></h3>

<p>A statement can be given a “label.” This is a symbol that you can use to
refer to the labeled statement, such as in
<code class="language-plaintext highlighter-rouge">goto</code> or <code class="language-plaintext highlighter-rouge">break</code>
statements.</p>

<p>Statement labels have function/method scope. That is, a label is visible
within the <em>entire</em> function or method in which it’s defined, but is not
visible outside the function or method. Even if a label is defined
within a nested code block, it’s still visible throughout the entire
function.</p>

<p>You label a statement by writing the label, followed by a colon,
followed by the statement itself. For example, this function contains an
<code class="language-plaintext highlighter-rouge">if</code> statement labeled
“<code class="language-plaintext highlighter-rouge">stm1</code>”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    myFunc(x)
    {
    stm1:
      if (x &gt; 1)
      {
        --x;
        goto stm1;
      }
    }
</code></pre></div></div>

<p>A statement label <strong>must</strong> be followed by a statement. While this might
seem obvious, there’s a common situation where you might accidentally
write a label without a statement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    myFunc(x)
    {
      if (x == 1)
      {
        // do some work...

        // check for errors
        if (errorOccurred())
          goto done;

        // do some more work...

      done:  // WRONG!!! there's no statement for this label!
      }
    }
</code></pre></div></div>

<p>In this example, what we’d like to do is to jump to the end of the
<code class="language-plaintext highlighter-rouge">if</code> block if an error has occurred at a certain
point, to bypass the remaining work we were going to do. The problem is
that we’ve written our label just before the closing brace of the
<code class="language-plaintext highlighter-rouge">if</code> block. A closing brace doesn’t constitute a
statement, so it’s illegal to put a label here. Fortunately, this is
easily solved: all we have to do is add an empty statement after the
label:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      done: ;  // this is fine, since we have a statement for the label now
</code></pre></div></div>

<h3 id="empty-statements"><span id="emptystm">Empty statements</span></h3>

<p>The “empty statement” consists of merely a semicolon:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ;
</code></pre></div></div>

<p>When executed, an empty statement has no effect.</p>

<p>Despite their meaninglessness at run-time, empty statements are useful
in certain situations. One use is to supply the required statement for a
label at the end of a code block. Another is to provide an empty loop
body for a <code class="language-plaintext highlighter-rouge">for</code> or other looping statement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (i = 1 ; i &lt; 10 ; handle(i++)) ;
</code></pre></div></div>

<p>In this example, everything the loop needs to do is written within the
<code class="language-plaintext highlighter-rouge">for</code> statement itself, so we don’t need
anything in the loop body. But the syntax of the
<code class="language-plaintext highlighter-rouge">for</code> statement requires us to supply
<em>something</em> as the loop body regardless, so we can use an empty
statement to fill the syntactic need without adding any run-time
overhead.</p>

<h3 id="local"><span id="local">local</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">local</code> statement defines one or more local
variables, and optionally assigns initial values to them.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local varName [ = expression ]  [ , ... ]  ;
</code></pre></div></div>

<p>Local variables are in scope from the <code class="language-plaintext highlighter-rouge">local</code>
statement to the end of the enclosing code block. A local is <strong>not</strong> in
scope before the <code class="language-plaintext highlighter-rouge">local</code> statement that defines
it (“before” meaning earlier in the source text), and it goes out of
scope at the closing brace of its enclosing code block.</p>

<p>It’s legal to define a local variable in a nested code block with the
same name as a variable in the enclosing code block. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    myFunc(x)
    {
      local a = 7;

      if (x == 1)
      {
        local a = x;
      }

      return a;
    }
</code></pre></div></div>

<p>This function as written always returns 7, because the local variable
named <code class="language-plaintext highlighter-rouge">a</code> that’s definfed within the
<code class="language-plaintext highlighter-rouge">if</code> statement’s code block is a different
variable from the <code class="language-plaintext highlighter-rouge">a</code> defined within the
function’s main code block. The two <code class="language-plaintext highlighter-rouge">a</code>’s share
the same name, but they’re nonetheless distinct variables: so assigning
<code class="language-plaintext highlighter-rouge">x</code> to the “inner” <code class="language-plaintext highlighter-rouge">a</code>
has no effect on the “outer” <code class="language-plaintext highlighter-rouge">a</code>.</p>

<p>When you define a local variable in a nested block with the same name as
a local defined in an enclosing block, the variable in the nested block
“hides” the one in the enclosing block as long as it’s in scope. There’s
no way to refer to the hidden variable from within the nested block in
this case.</p>

<p>If no initializer is supplied for a variable, the local variable is
initialized to nil at entry to the function or method containing the
<code class="language-plaintext highlighter-rouge">local</code> statement. If an initializer is
supplied, the expression is evaluated when the
<code class="language-plaintext highlighter-rouge">local</code> statement is executed, and the value is
assigned to the local variable.</p>

<p>Each initializer expression applies to one variable only. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local a, b, c = 7;
</code></pre></div></div>

<p>This initializes <code class="language-plaintext highlighter-rouge">c</code> to 7, and leaves
<code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> with the
default <code class="language-plaintext highlighter-rouge">nil</code> value.</p>

<p><code class="language-plaintext highlighter-rouge">local</code> statements that include initializers
count as executable statements. This means that they’re executed as
they’re encountered, just like any other statement. This is important to
keep in mind when writing a loop:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (i = 0 ; i &lt; 10 ; ++i)
    {
      local j = 7;

      if (i &lt; j)
        ++j;
    }
</code></pre></div></div>

<p>The important thing to note here is that <code class="language-plaintext highlighter-rouge">j</code> is
re-initialized to 7 <em>every time through the loop</em>.</p>

<p>If a <code class="language-plaintext highlighter-rouge">local</code> statement doesn’t include an
initializer for a variable, that variable is initialized to
<code class="language-plaintext highlighter-rouge">nil</code> at entry to the function or method, but is
<strong>not</strong> reset to <code class="language-plaintext highlighter-rouge">nil</code> each time the
<code class="language-plaintext highlighter-rouge">local</code> statement is executed. In fact, a
<code class="language-plaintext highlighter-rouge">local</code> statement without an initializer doesn’t
have any run-time effect, other than to reserve space for the local
variable when the function or method is entered.</p>

<h3 id="expression-statements"><span id="exprstm">Expression statements</span></h3>

<p>An expression, all by itself, counts as a statement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expression ;
</code></pre></div></div>

<p>Expression statements are typically the most numerous type of statement
in a program, because they’re the main way to call functions and
methods, assign values to variables, invoke intrinsic functions, and so
on.</p>

<p>When you write an expression as a statement, it’s virtually always to
invoke the side effects of the expression. It’s pointless to write an
expression statement where the expression has no side effects:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x + 2;  // a pointless statement!
</code></pre></div></div>

<p>That does nothing meaningful: it adds 2 to x, but since the expression
doesn’t do anything with the result, the result is simply discarded.</p>

<p>So, typically, an expression statement includes something with side
effects:</p>

<ul>
  <li>a function call</li>
  <li>a method call</li>
  <li>assigning a value to a variable</li>
  <li>incrementing or decrementing a variable with
<code class="language-plaintext highlighter-rouge">++</code> or <code class="language-plaintext highlighter-rouge">--</code></li>
</ul>

<p>Here are some examples:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    myFunc(7);
    x = x + 3;
    myObj.weight *= 2;
</code></pre></div></div>

<h3 id="double-quoted-string-statement"><span id="dqstm">Double-quoted string statement</span></h3>

<p>A double-quoted string, written by itself as a statement, displays the
string. (More precisely, it calls the default display function, which
the default startup sets to <code class="language-plaintext highlighter-rouge">tadsSay()</code>, with
the string’s text as the argument.) For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Hello, world!\n";
</code></pre></div></div>

<p>In addition to displaying fixed text, double-quoted strings can display
embedded variables and expressions. You embed an expression within a
double-quoted string by enclosing the expression within
<code class="language-plaintext highlighter-rouge">\&lt;\&lt; \&gt;\&gt;</code> marks within the string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "x = &lt;&lt;x&gt;&gt;, y*5 = &lt;&lt;y*5&gt;&gt;\n";
</code></pre></div></div>

<p>The compiler treats this as though it were a series of statements like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    {
      "x = ";
      tadsSay(x);
      ", y*5 = ";
      tadsSay(y*5);
      "\n";
    }
</code></pre></div></div>

<p>Embedded expressions are evaluated each time they’re encountered. The
expressions within a string are evaluated in the order in which they
appear in the string. Expression values are displayed according to their
datatype:</p>

<ul>
  <li><strong>string:</strong> the text of the string is displayed</li>
  <li><strong>integer:</strong> the decimal representation of the number is displayed</li>
  <li><strong>BigNumber:</strong> the number is displayed using the default formatting</li>
  <li><strong>nil:</strong> nothing is displayed</li>
  <li><strong>all other types:</strong> a run-time error (“invalid type”) is generated</li>
</ul>

<p>For more on embedded expressions, see the section on <a href="strlit.html#embeddings">string
literals</a>.</p>

<h3 id="return"><span id="return">return</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">return</code> statement exits the current
function or method and resumes execution in the caller. Optionally, the
statement can specify an expression to evaluate as the return value of
the function or method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return [ expression ]  ;
</code></pre></div></div>

<p>If an expression is specified, it’s evaluated when the
<code class="language-plaintext highlighter-rouge">return</code> statement is executed, and the result
is returned to the caller as the result value of the current function or
method. If no expression is specified, the default return value of
<code class="language-plaintext highlighter-rouge">nil</code> is used.</p>

<p>When a <code class="language-plaintext highlighter-rouge">return</code> statement is executed, the VM
first executes the <code class="language-plaintext highlighter-rouge">finally</code> clause of each
enclosing <code class="language-plaintext highlighter-rouge">try</code> statement, working from the
innermost outward. It then exits the function and resumes execution in
the caller.</p>

<h3 id="if"><span id="if">if</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">if</code> statement executes a statement if a
given condition is true, and can optionally execute a different
statement if the given condition is false.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ( conditionExpression )
  thenPart
[ else
  elsePart ] 
</code></pre></div></div>

<p>Each of <span class="synPar">thenPart</span> and
<span class="synPar">elsePart</span> are single statements, or code
blocks enclosed in braces.</p>

<p>The <code class="language-plaintext highlighter-rouge">if</code> statement first evaluates the condition
expression. Then:</p>

<ul>
  <li>If the result is anything except 0 or <code class="language-plaintext highlighter-rouge">nil</code>,
the <span class="synPar">truePart</span> is executed, then execution
jumps to the next statement after the entire
<code class="language-plaintext highlighter-rouge">if</code>.</li>
  <li>Otherwise:
    <ul>
      <li>If an <code class="language-plaintext highlighter-rouge">else</code> clause is specified, the
<span class="synPar">elsePart</span> is executed, then execution
resumes at the next statement.</li>
      <li>If there’s no <code class="language-plaintext highlighter-rouge">else</code> clause, execution jumps
directly to the next statement.</li>
    </ul>
  </li>
</ul>

<p>Since TADS uses a C-like syntax, it inherits a sometimes
counterintuitive quirk of C that affects nested
<code class="language-plaintext highlighter-rouge">if</code> statements. Consider the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (a == 1)
      if (b == 2)
        doSomething(a, b);
    else
      somethingElse(a, b);
</code></pre></div></div>

<p>Based on the indentation, the person who wrote this code seemed to be
thinking that the <code class="language-plaintext highlighter-rouge">somethingElse()</code> line would
be reached if <code class="language-plaintext highlighter-rouge">a != 1</code>. But that isn’t the case:
look more closely and you’ll see that the <code class="language-plaintext highlighter-rouge">else</code>
actually attaches to the <em>second</em> <code class="language-plaintext highlighter-rouge">if</code>. An
<code class="language-plaintext highlighter-rouge">else</code> always goes with the nearest possible
preceding <code class="language-plaintext highlighter-rouge">if</code>. So this code will simply do
nothing if <code class="language-plaintext highlighter-rouge">a != 1</code>.</p>

<p>To fix this, we have to add some braces to make the grouping explicit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (a == 1)
    {
      if (b == 2)
        doSomething(a, b);
    }
    else
      somethingElse(a, b);
</code></pre></div></div>

<p>This makes it impossible for the <code class="language-plaintext highlighter-rouge">else</code> to
attach to the second <code class="language-plaintext highlighter-rouge">if</code>, because the
<code class="language-plaintext highlighter-rouge">if</code> is tucked away inside the nested code block
and therefore out of consideration back in the main code block.</p>

<h3 id="for"><span id="for">for</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">for</code> statement is a flexible and powerful
looping construct that lets you construct almost any kind of loop.</p>

<p>TADS has three different kinds of <code class="language-plaintext highlighter-rouge">for</code> loops:
the standard C <code class="language-plaintext highlighter-rouge">for</code> loop, which is very similar
to its counterpart in C++; the <code class="language-plaintext highlighter-rouge">for..in</code> loop,
which works exactly like <a href="#foreach"><code class="language-plaintext highlighter-rouge">foreach</code></a>;
and the “range” loop, which makes it easy to write a loop over a range
of integer values.</p>

<h4 id="c-style-for-loops"><span id="cfor">C-style <code class="language-plaintext highlighter-rouge">for</code> loops</span></h4>

<p>The basic <code class="language-plaintext highlighter-rouge">for</code> loop in TADS is almost identical
to the {[for}} loop in C, C++, Javascript, and most other C-like
languages. It has this basic syntax:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( [ initializer ]  ; [ condition ]  ; [ updater ]  )
  loopBody
</code></pre></div></div>

<p>The <span class="synPar">initializer</span> is either an ordinary
expression, or a list of local variable declarations, or a mix of both:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>( expression | local varName = expression )  [ , ... ] 
</code></pre></div></div>

<p>Note the difference from ordinary <code class="language-plaintext highlighter-rouge">local</code>
statements: the initializer expression is <em>required</em> for a local
variable defined here.</p>

<p>Local variables defined in a <code class="language-plaintext highlighter-rouge">for</code> statement are
only in scope within the <code class="language-plaintext highlighter-rouge">for</code> loop. They’re in
scope within all of the expressions that are part of the
<code class="language-plaintext highlighter-rouge">for</code> statement itself (the initializer,
condition, and updater expressions), and they’re in scope within the
body of the loop. The <code class="language-plaintext highlighter-rouge">for</code> statement has its
own new nested scope that starts just before the
<code class="language-plaintext highlighter-rouge">for</code> and ends at the end of its loop body; the
locals exist within this nested scope.</p>

<p>In practice, the expressions within the
<span class="synPar">initializer</span> section are almost always
assignment expressions. The point is to initialize the variables used
within the loop to their starting values for the loop.</p>

<p>The <span class="synPar">condition</span> and
<span class="synPar">updater</span> are ordinary expressions, and the
<span class="synPar">loopBody</span> is a single statement, or a block
of statements enclosed in braces.</p>

<p>The C-style <code class="language-plaintext highlighter-rouge">for</code> statement executes as follows:</p>

<ul>
  <li>1. Evaluate each element of the
<span class="synPar">initializer</span> list, starting from the left.</li>
  <li>2. If there’s a <span class="synPar">condition</span>, evaluate it.
If result is 0 or <code class="language-plaintext highlighter-rouge">nil</code>, we’re done with the
<code class="language-plaintext highlighter-rouge">for</code>, so jump to the next statement after the
loop body. Otherwise, proceed to step 3. If there’s no
<span class="synPar">condition</span>, proceed to step 3.</li>
  <li>3. Execute <span class="synPar">loopBody</span> once.</li>
  <li>4. Evaluate <span class="synPar">updater</span>, if specified.</li>
  <li>5. Go to step 2.</li>
</ul>

<p>An important feature of this procedure is that the
<span class="synPar">condition</span> expression is evaluated <em>before
the first iteration</em>. That means that if the condition is false (i.e., 0
or <code class="language-plaintext highlighter-rouge">nil</code>) before the first iteration, the loop
body is never executed. Therefore, it’s possible for a
<code class="language-plaintext highlighter-rouge">for</code> loop to iterate zero times.</p>

<p>Another feature to note is that the <span class="synPar">updater</span>
expression is evaluated <em>after each iteration</em>, before the
<span class="synPar">condition</span> is re-tested.</p>

<p>C-style <code class="language-plaintext highlighter-rouge">for</code> statements are extremely flexible.
The statement doesn’t do anything implicitly - it doesn’t increment any
variables automatically, or anything else. This is a departure from many
programming languages, where similar looping constructs implicitly
increment a variable on each iteration. With the
<code class="language-plaintext highlighter-rouge">for</code> statement, you have to explicitly say what
you want to do on each iteration. Although that’s a little more work,
the benefit is that you can do exactly what you want, no matter how
unusual: if you want to increment a variable by the <em>n</em>th Fibonacci
number each time through, you can easily do that.</p>

<p>Note that each of the expression parts - the
<span class="synPar">initializer</span>, the
<span class="synPar">condition</span>, and the
<span class="synPar">updater</span> - are allowed to be completely
empty. You still have to write all of the semicolons, but it’s legal to
write <em>only</em> the semicolons. This is a valid loop:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (;;)
    {
      // do some work...
    }
</code></pre></div></div>

<p>Because there’s no <span class="synPar">condition</span> expression,
this statement will loop forever, unless there’s a statement within the
loop that exits the loop or the entire function (such as
<code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">goto</code>,
<code class="language-plaintext highlighter-rouge">return</code>, or <code class="language-plaintext highlighter-rouge">throw</code>).</p>

<p>Here’s a more typical example of a <code class="language-plaintext highlighter-rouge">for</code> loop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 1 ; i &lt;= lst.length() ; ++i)
    {
      "lst[&lt;&lt;i&gt;&gt;] = &lt;&lt;lst[i]&gt;&gt;\n";
    }
</code></pre></div></div>

<p>This loop goes through a list, displaying each element. It uses the
counter variable <code class="language-plaintext highlighter-rouge">i</code> (defined as local to the
loop): it starts by setting <code class="language-plaintext highlighter-rouge">i</code> to 1, and
continues looping as long as <code class="language-plaintext highlighter-rouge">i</code> is less than or
equal to the length of the list; each time through the loop, it
increments <code class="language-plaintext highlighter-rouge">i</code>, to move to the next list
element.</p>

<p>You could speed up this example a little bit by saving the length of the
list in another loop local variable. This takes advantage of the ability
to use more than one <code class="language-plaintext highlighter-rouge">local</code> clause in a
<code class="language-plaintext highlighter-rouge">for</code> initializer.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 1, local len = lst.length() ; i &lt;= len ; ++i) ...
</code></pre></div></div>

<p>That works the same as our original example, but runs a little faster,
because it doesn’t have to call <code class="language-plaintext highlighter-rouge">lst.length()</code>
every time through the loop.</p>

<h4 id="forin"><span id="forIn">for..in</span></h4>

<p>The <code class="language-plaintext highlighter-rouge">for</code> statement can alternatively iterate
over the elements of a collection. The syntax for this is exactly the
same as for the <a href="#foreach"><code class="language-plaintext highlighter-rouge">foreach</code></a> statement,
other than using <code class="language-plaintext highlighter-rouge">for</code> in place of
<code class="language-plaintext highlighter-rouge">foreach</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( [ local ]  loopVar in expression )
   loopBody
</code></pre></div></div>

<p>For..in loops are new in TADS 3.1; in older versions, only the
<code class="language-plaintext highlighter-rouge">foreach</code> statement accepted this syntax. The
<code class="language-plaintext highlighter-rouge">for</code> syntax was added for two reasons. First,
it simplifies the language’s syntax: you don’t have to remember to use a
different statement keyword for collection loops. Second, it lets you
<a href="#combinedFor">combine</a> the collection syntax with the standard C-style
<code class="language-plaintext highlighter-rouge">for</code> syntax, so that you can add other
variables (counters, sums, etc.) to a collection loop.</p>

<h4 id="forin-range"><span id="forInRange">for..in range</span></h4>

<p>The third type of <code class="language-plaintext highlighter-rouge">for</code> loop iterates over a
range of integers. This is by far the most common type of
<code class="language-plaintext highlighter-rouge">for</code> loop, so TADS provides this special syntax
to make the meaning a little clearer.</p>

<p>The syntax for an integer range loop is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for ( [ local ]  loopVar in fromExpr .. toExpr [ step stepExpr ]  )
   loopBody
</code></pre></div></div>

<p>As with other <code class="language-plaintext highlighter-rouge">for</code> loops, the
<code class="language-plaintext highlighter-rouge">local</code> keyword lets you define a new local
variable for the loop’s control variable, with its scope limited to the
loop. If you don’t use <code class="language-plaintext highlighter-rouge">local</code>, the loop
variable can be any local variable defined before the
<code class="language-plaintext highlighter-rouge">for</code>.</p>

<p><em>fromExpr</em>, <em>toExpr</em>, and the optional <em>stepExpr</em> are expressions that
evaluate to integer values. If there’s no <code class="language-plaintext highlighter-rouge">step</code>
clause, the default step value is 1.</p>

<p>The integer range loop is executed as follows:</p>

<ul>
  <li>1. <em>fromExpr</em> is evaluated, and the result is assigned to <em>loopVar</em>.</li>
  <li>2. <em>toExpr</em> and (if it’s present) <em>stepExpr</em> are evaluated, in that
order, and the results are stored in temporary memory locations.</li>
  <li>3. <em>loopVar</em> is compared to the value of <em>toExpr</em> calculated in
step 2. If the saved <em>stepExpr</em> is positive, we exit the loop if
<em>loopVar</em> is the result is “greater than”. If <em>stepExpr</em> was negative,
we exit if the result is “less than”. Otherwise we continue to step 4.</li>
  <li>4. Execute the loop body one time.</li>
  <li>5. Add the <em>stepExpr</em> value calculated in step 2 to <em>loopVar</em>.</li>
  <li>6. Go to step 3.</li>
</ul>

<p>In step 3, note how the loop exits if the loop’s control variable goes
<em>beyond</em> the <em>toExpr</em> limit, where the direction of “beyond” depends on
whether the step increment is positive or negative. If the step is
positive, we’re looping from a lower value to a higher value, so we stop
when the loop variable is greater than the “to” limit. Likewise, if the
step is negative, we’re going from a higher value to a lower value, so
we stop when the loop variable is less than the “to” limit.</p>

<p>Take special note of how <em>toExpr</em> and <em>stepExpr</em> are used in the loop.
They’re only evaluated <em>once</em>, at the start of the loop (in step 2).
This is important, because it means that if any of these values change
during the loop, it doesn’t affect the loop boundaries. The original
values at the start of the loop determine the loop’s limits. Consider
this example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local lst = ['a', 'b', 'c'];
    for (local i in 1..lst.length())
       lst += lst[i];
</code></pre></div></div>

<p>Each time through this loop, we append a new element to the end of the
list. This means that <code class="language-plaintext highlighter-rouge">lst.length()</code> increases
by 1 on each iteration. If we re-evaluated
<code class="language-plaintext highlighter-rouge">lst.length()</code> each time through, this loop
would never end - both <code class="language-plaintext highlighter-rouge">i</code> and
<code class="language-plaintext highlighter-rouge">lst.length()</code> are incremented by 1 each time
through, so <code class="language-plaintext highlighter-rouge">i</code> would never catch up with
<code class="language-plaintext highlighter-rouge">lst.length()</code>. But we <em>don’t</em> re-evaluate
<code class="language-plaintext highlighter-rouge">lst.length()</code> each time through; instead, the
original value is calculated at the start of the loop, and that value is
used to determine when the loop ends, no matter what happens once we
start going through the loop. So the loop in this example runs only
three times, then exits.</p>

<p>The single evaluation of <em>toExpr</em> and <em>stepExpr</em> is also good for
efficiency. With traditional C-style loops, it’s common to write
something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 1, local len = lst.length() ; i &lt;= len ; ++i) ...
</code></pre></div></div>

<p>The point of creating the extra local <code class="language-plaintext highlighter-rouge">len</code> is
to speed up the code a little by avoiding a call to
<code class="language-plaintext highlighter-rouge">lst.length()</code> every time through the loop. The
<code class="language-plaintext highlighter-rouge">for..in</code> syntax is equally efficient, because
it does the same thing. It just saves you the trouble of coding the
extra step by hand, and makes the code easier to read.</p>

<h4 id="combining-for-forin-and-forin-range"><span id="combinedFor">Combining <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">for..in</code>, and <code class="language-plaintext highlighter-rouge">for..in range</code></span></h4>

<p>So far, we’ve presented the <code class="language-plaintext highlighter-rouge">for</code> statement as
though it had three separate syntax options: the standard C-style
<code class="language-plaintext highlighter-rouge">for</code>, the collection loop with
<code class="language-plaintext highlighter-rouge">for (x in y)</code>, and the integer range loop with
<code class="language-plaintext highlighter-rouge">for (i in a..b)</code>. These aren’t actually
separate statement types, though - they’re simply special cases of the
standard <code class="language-plaintext highlighter-rouge">for</code>, which encompasses all three loop
styles. The really interesting thing is that you can combine all three
types in a single loop. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 1, local ele in lst ; ; ++i)
       "lst[&lt;&lt;i&gt;&gt;] = &lt;&lt;lst[i]&gt;&gt;\n";
</code></pre></div></div>

<p>That kind of loop is cumbersome to write with
<code class="language-plaintext highlighter-rouge">foreach</code>, since there’s no way to include an
extra counter variable with the collection loop.
<code class="language-plaintext highlighter-rouge">for</code>’s ability to combine the loop styles makes
for shorter code that’s often clearer, since the extra variables
involved in the loop can be coded right into the
<code class="language-plaintext highlighter-rouge">for</code> structure.</p>

<p>The key to combining the three types of <code class="language-plaintext highlighter-rouge">for</code>
loops is that <code class="language-plaintext highlighter-rouge">x in y</code> and <code class="language-plaintext highlighter-rouge">i
in a..b</code> are really just syntax options for the “initializer”
clause of the C-style <code class="language-plaintext highlighter-rouge">for</code> statement. You can
freely mix these with one another and with ordinary initializer
expressions.</p>

<p>When you use <code class="language-plaintext highlighter-rouge">x in y</code> or <code class="language-plaintext highlighter-rouge">i in
a..b</code> in an initializer, the condition and updater clauses of the
<code class="language-plaintext highlighter-rouge">for</code> become optional. You can omit them
entirely, including the semicolons that separate the three clauses. The
<code class="language-plaintext highlighter-rouge">for (x in y)</code> and <code class="language-plaintext highlighter-rouge">for (i in
a..b)</code> statements we saw earlier, then, are nothing special:
they’re just the simplest <code class="language-plaintext highlighter-rouge">for</code> statements with
the respective initializer types. The reason that the condition and
updater clauses are optional when using an “in” clause is that an “in”
clause supplies its own implicit condition and updater - so if you have
nothing else to add to those parts, the compiler lets you leave them out
entirely, to keep the code uncluttered.</p>

<p>Here’s the full sequence of events when processing a hybrid loop that
contains regular initializers, conditions, and updaters, as well as
<code class="language-plaintext highlighter-rouge">in</code> clauses:</p>

<ul>
  <li>1. For each initializer, in order of appearance:
    <ul>
      <li>If it’s an ordinary expression, evaluate it.</li>
      <li>If it’s an <code class="language-plaintext highlighter-rouge">x in y</code> clause, evaluate the
<em>collection</em> expression, then call the
<code class="language-plaintext highlighter-rouge">createIterator()</code> method on the result.
Store the method result in a temporary memory location (“the
iterator”).</li>
      <li>If it’s an <code class="language-plaintext highlighter-rouge">i in a..b</code> clause, evaluate the
<em>fromExpr</em>, and assign the result to the control variable. Then,
evaluate <em>toExpr</em> and (if present) <em>stepExpr</em>, and store the results
in temporary memory locations.</li>
    </ul>
  </li>
  <li>2. For each <code class="language-plaintext highlighter-rouge">in</code> clause among the
initializers, in order of appearance:
    <ul>
      <li>For an <code class="language-plaintext highlighter-rouge">x in y</code> clause, call the
<code class="language-plaintext highlighter-rouge">isNextAvailable()</code> method on the iterator.
If it returns <code class="language-plaintext highlighter-rouge">nil</code>, exit the loop.
Otherwise call the iterator’s <code class="language-plaintext highlighter-rouge">getNext()</code>
method and store the result in the clause’s <em>loopVar</em>.</li>
      <li>For an <code class="language-plaintext highlighter-rouge">i in a..b</code> clause, compare the
clause’s <em>loopVar</em> to the saved value of <em>toExpr</em> from step 1. If
it’s “beyond” the <em>toExpr</em> value (greater than <em>toExpr</em> if the step
value is positive, less than <em>toExpr</em> if the step value is
negative), exit the loop.</li>
    </ul>
  </li>
  <li>3. If there’s a <em>condition</em> expression, evaluate it. If the result is
<code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">nil</code>, exit the
loop.</li>
  <li>4. Execute the loop body once.</li>
  <li>5. If there’s an <em>updater</em> expression, evaluate it.</li>
  <li>6. For each <code class="language-plaintext highlighter-rouge">i in a..b</code> clause (in the order
of the initializers), add the saved value of <em>stepExpr</em> from step 1 to
<em>loopVar</em>.</li>
  <li>7. Go to step 2.</li>
</ul>

<p>In a nutshell, this works just like the standard C
<code class="language-plaintext highlighter-rouge">for</code> loop, except for two additions. First,
<strong>before</strong> the explicit <em>condition</em> expression is tested,
<code class="language-plaintext highlighter-rouge">x in y</code> and <code class="language-plaintext highlighter-rouge">i in a..b</code>
clauses are tested, and the loop terminates if any of them are finished.
Second, <strong>after</strong> the explicit <em>updater</em> expression is executed,
<code class="language-plaintext highlighter-rouge">i in a..b</code> loop control variables are
incremented by their step values. The explicit <em>updater</em> is executed
first so that it can refer to the current values of the
<code class="language-plaintext highlighter-rouge">in</code> control variables, from the loop iteration
that just finished, if desired.</p>

<h3 id="foreach"><span id="foreach">foreach</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">foreach</code> statement iterates over a
Collection object’s contents. It executes a statement (or group of
statements) once for each element of a Collection.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach ( loopVar in expression )
  loopBody
</code></pre></div></div>

<p><span class="synPar">loopVar</span> can take one of two forms: it can be
any “lvalue” (see the <a href="expr.html#commonEles">expressions</a> section for
details), such as a local variable, an object property, or an indexed
lvalue; or it can be of this form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local localName
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">local</code> syntax defines a new local variable,
scoped to the <code class="language-plaintext highlighter-rouge">foreach</code> statement. (This works
the same way as it does with the <code class="language-plaintext highlighter-rouge">for</code>
statement.) If the <code class="language-plaintext highlighter-rouge">local</code> keyword is not
specified, the local variable with the given name from the enclosing
scope is used.</p>

<p>The <span class="synPar">expression</span> is any expression, but when
evaluated it must yield a Collection object - a list, a Vector, or a
LookupTable.</p>

<p>The <span class="synPar">loopBody</span> is a single statement, or a
group of statements enclosed in braces.</p>

<p>The statement first evaluates the
<span class="synPar">expression</span>. This must yield a Collection
object; if not, a run-time error results. The statement then iterates
over the elements of the collection, one at a time. For each element of
the collection, the statement sets the looping variable
<span class="synPar">loopVar</span> to the current element, and executes
the <span class="synPar">loopBody</span> once.</p>

<p>For a mutable object like a Vector or a HashTable,
<code class="language-plaintext highlighter-rouge">foreach</code> automatically creates a “safe” copy of
the object at the beginning of the iteration, and uses the safe copy
throughout the iteration. This ensures that the loop executes exactly
once for each element of the collection <em>as it was at the start of the
loop</em>, even if the loop body makes changes to the collection. This makes
it safe to make arbitrary changes to the collection in the loop body.
For example, you can insert new element into a Vector, or delete
existing elements. Changes you make from within the loop body will not
affect the iteration.</p>

<p>The order of the iteration depends on the type of the collection. For
lists and Vectors, the iteration is in ascending index order. For
LookupTables, the order is arbitrary.</p>

<p>The “element” value that’s assigned to the looping variable on each
iteration depends on the type of collection. For a list or a Vector,
it’s simply the element value. For a LookupTable, it’s the <em>value</em> at a
given key, <em>not</em> the key itself.</p>

<p>Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    foreach (local ele in lst)
      "&lt;&lt;ele&gt;&gt;... ";
</code></pre></div></div>

<p>This simply runs through a collection and displays each element.
Assuming <code class="language-plaintext highlighter-rouge">lst</code> is a list, the elements are
displayed in ascending index order.</p>

<p>Here’s an example that takes advantage of the “snapshot” feature - the
safe copy that <code class="language-plaintext highlighter-rouge">foreach</code> creates before
beginning the iteration.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local i = 1;
    local vec = new Vector(10).fillValue(nil, 1, 10).applyAll({x: i++});

    foreach (local x in vec)
    {
      vec.applyAll({v: v+1});
      "&lt;&lt;x&gt;&gt;\n";
    }
</code></pre></div></div>

<p>The first two lines create a Vector and initialize its elements to the
integers 1 through 10, using the <code class="language-plaintext highlighter-rouge">applyAll()</code>
method of the Vector. The <code class="language-plaintext highlighter-rouge">foreach</code> body
modifies the entire Vector, by adding 1 to each element, then prints out
the current value. At first glance, we might expect the values displayed
to be something like this: 1, 3, 5, 7, 9, …; we might expect this
because of the <code class="language-plaintext highlighter-rouge">applyAll()</code> call updates every
element of the Vector on every iteration of the loop. This isn’t what
happens, though: because the <code class="language-plaintext highlighter-rouge">foreach</code> iterates
a copy of the Vector, we actually print out the original contents of the
Vector: 1, 2, 3, 4, and so on. After we’re finished with the iteration,
though, if we look at the Vector, we’ll find it modified as we’d expect.
In addition, even within the loop, if we were to refer directly to the
Vector through the variable <code class="language-plaintext highlighter-rouge">vec</code>, we’d find it
modified as we’d expect - the snapshot pertains only the iteration
variable, and doesn’t “freeze” the Vector itself. To see this, consider
this more complex example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local i = 1;
    local vec = new Vector(10).fillValue(0, 1, 10).applyAll({x: i++});

    i = 1;
    foreach (local x in vec)
    {
      vec.applyAll({v: v+1});
      "x = &lt;&lt;x&gt;&gt;, vec[&lt;&lt;i&gt;&gt;] = &lt;&lt;vec[i]&gt;&gt;\n";
      ++i;
    }
</code></pre></div></div>

<p>This would display the following, showing that the vector has been
modified - and the modifications are visible within the loop - even
though the modifications are not visible to the iteration variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = 1, vec[1] = 2
    x = 2, vec[2] = 4
    x = 3, vec[3] = 6
    x = 4, vec[4] = 8
    x = 5, vec[5] = 10
    x = 6, vec[6] = 12
    x = 7, vec[7] = 14
    x = 8, vec[8] = 16
    x = 9, vec[9] = 18
    x = 10, vec[10] = 20
</code></pre></div></div>

<p>Although we’ve belabored this snapshot behavior as though it were some
pitfall you must take care to avoid, the snapshot actually simplifies
things greatly for most common situations. The snapshot relieves you
from having to worry about how the iteration will proceed. Even if
you’re making changes to the contents of the collection during the loop,
you can be confident that the updates will have no effect on the
iteration. The snapshot feature makes it easy to iterate over
collections without having to worry about the details of how changes
would affect the order of the elements, or the number of elements, or
anything else.</p>

<p>For those who are curious, here are the gory, internal details on how
<code class="language-plaintext highlighter-rouge">foreach</code> actually executes. It first evaluates
the <span class="synPar">expression</span>, then calls the
<code class="language-plaintext highlighter-rouge">createIterator()</code> method on the resulting
value. It stores this value in a temporary variable, which we’ll call
<em>I</em>. It then loops as follows: call
<em>I</em><code class="language-plaintext highlighter-rouge">.isNextAvailable()</code>; if this is
<code class="language-plaintext highlighter-rouge">nil</code>, exit the loop; otherwise call
<em>I</em><code class="language-plaintext highlighter-rouge">.getNext()</code>, and assign the result to the
looping variable <span class="synPar">loopVar</span>, then execute the
loop body once, then go to the top of the loop.</p>

<h3 id="while"><span id="while">while</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">while</code> statement sets up a simple loop that
repeats as long as a condition is true.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ( conditionExpression )
   loopBody
</code></pre></div></div>

<p>The <span class="synPar">conditionExpression</span> is any expression,
and the <span class="synPar">loopBody</span> is a single statement or a
group of statements enclosed in braces.</p>

<p>A <code class="language-plaintext highlighter-rouge">while</code> statement is executed as follows:</p>

<ul>
  <li>1. Evaluate the condition expression. If the result is 0 or
<code class="language-plaintext highlighter-rouge">nil</code>, exit the loop, by jumping to the next
statement after the loop body. Otherwise, proceed to step 2.</li>
  <li>2. Execute the loop body once.</li>
  <li>3. Go to step 1.</li>
</ul>

<p>The condition expression is evaluated before every iteration of the
loop - even before the first iteration, which means that the loop can
execute zero times, if the condition is initially false.</p>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local iter = coll.createIterator();
    while (iter.isNextAvail())
    {
      local ele = iter.getNext();
      "The next element is: &lt;&lt;ele&gt;&gt;\n";
    }
</code></pre></div></div>

<h3 id="dowhile"><span id="dowhile">do…while</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code>
statement sets up a loop similar to a <code class="language-plaintext highlighter-rouge">while</code>
loop, but with the important difference that the loop condition is
tested <em>after</em> each iteration, rather than at the beginning. This means
that a <code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code>
loop always executes <em>at least once</em>, since the loop condition isn’t
tested until after the first iteration.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do
  loopBody
while ( conditionExpression ) ;
</code></pre></div></div>

<p>The <span class="synPar">conditionExpression</span> is any expression,
and the <span class="synPar">loopBody</span> is one statement or a group
of statements enclosed in braces.</p>

<p>A <code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code> loop is
executed as follows:</p>

<ul>
  <li>1. Execute the loop body once.</li>
  <li>2. Evaluate the condition expression. If the result is 0 or nil, exit
the loop by jumping to the next statement after the
<code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code>.
Otherwise, go to step 1.</li>
</ul>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = 'a';
    do
    {
        "x = &lt;&lt;a&gt;&gt;\n";
        x += 'a';
    } while (a.length() &lt; 10);
</code></pre></div></div>

<h3 id="switch"><span id="switch">switch</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">switch</code> statement selects one of several
code branches, depending on the value of an expression.
<code class="language-plaintext highlighter-rouge">switch</code> is similar to a series of
<code class="language-plaintext highlighter-rouge">if</code>…<code class="language-plaintext highlighter-rouge">else
if</code>…<code class="language-plaintext highlighter-rouge">else if</code>… statements, but has
some advantages and restrictions over that approach.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch ( controlExpression )
{
  case value1 :
    caseBody1

  case value2 :
    caseBody2

  default :
    defaultBody
}
</code></pre></div></div>

<p>The <span class="synPar">controlExpression</span> is any expression.
This is used to select which “branch” of the
<code class="language-plaintext highlighter-rouge">switch</code> to execute.</p>

<p><span class="synPar">value1</span> and subsequent values are called the
“case labels.” These are <strong>constant</strong> expressions - that is, they must
be integers, enums, object names, string constants, property IDs,
function names, BigNumber constants, or lists containing only constant
expressions. These values can be expressions, as long as the expression
can be fully computed and reduced to a constant value at compile time.
For example, you can use a value like <code class="language-plaintext highlighter-rouge">1+2\*3</code>,
since the compiler can directly compute the integer value of this
expression; but you can’t use a value like
<code class="language-plaintext highlighter-rouge">a+1</code>, where <code class="language-plaintext highlighter-rouge">a</code> is a
local variable, because the value of a local variable can’t be
determined until the program is actually running. You can use any mix of
types among the case labels - that is, each case label can be of a
different datatype.</p>

<p>The <span class="synPar">caseBody</span> elements, and the
<span class="synPar">defaultBody</span>, each consist of zero or more
statements. Note that it’s legal for a case or default body to be empty,
so it’s legal for several <code class="language-plaintext highlighter-rouge">case</code> labels to
appear consecutively.</p>

<p>A <code class="language-plaintext highlighter-rouge">switch</code> must have at least one
<code class="language-plaintext highlighter-rouge">case</code> <em>or</em>. <code class="language-plaintext highlighter-rouge">default</code>
label, and can have at most one <code class="language-plaintext highlighter-rouge">default</code> label.
Any number of <code class="language-plaintext highlighter-rouge">case</code> labels can appear -
including zero, provided there’s a <code class="language-plaintext highlighter-rouge">default</code> to
meet the required minimum of one label overall. So, for example, a
<code class="language-plaintext highlighter-rouge">switch</code> that contains only a
<code class="language-plaintext highlighter-rouge">default</code> label is legal, as is a
<code class="language-plaintext highlighter-rouge">switch</code> with one <code class="language-plaintext highlighter-rouge">case</code>
label, or with five <code class="language-plaintext highlighter-rouge">case</code> labels, or with
<code class="language-plaintext highlighter-rouge">five</code> case labels and a
<code class="language-plaintext highlighter-rouge">default</code>. A completely empty
<code class="language-plaintext highlighter-rouge">switch</code> is illegal, as is a
<code class="language-plaintext highlighter-rouge">switch</code> with more than one
<code class="language-plaintext highlighter-rouge">default</code> label.</p>

<p>A <code class="language-plaintext highlighter-rouge">switch</code> statement is executed as follows.
First, the <span class="synPar">controlExpression</span> is evaluated.
The result is then compared to each case label value, one at a time, in
the order in which the labels appear in the source code. The comparison
is done according to the same rules as the <code class="language-plaintext highlighter-rouge">==</code>
operator. At the first match, execution jumps to the first
<span class="synPar">caseBody</span> statement following the matching
label. If no matches are found among the case labels, and there’s a
<code class="language-plaintext highlighter-rouge">default</code> label, execution jumps to the first
<span class="synPar">defaultBody</span> statement. If no matches are
found among the case labels, and there’s no
<code class="language-plaintext highlighter-rouge">default</code> label, execution jumps to the next
statement after the entire <code class="language-plaintext highlighter-rouge">switch</code> body.</p>

<p>Note that the <code class="language-plaintext highlighter-rouge">default</code> can go anywhere in the
<code class="language-plaintext highlighter-rouge">switch</code> without changing the behavior of the
<code class="language-plaintext highlighter-rouge">switch</code>. We always search <em>all</em> of the value
labels first, and only jump to the <code class="language-plaintext highlighter-rouge">default</code>
label if we can’t find a match. So you can even put the
<code class="language-plaintext highlighter-rouge">default</code> label first if you want - it won’t
change anything, since the value labels are always checked first, no
matter where the <code class="language-plaintext highlighter-rouge">default</code> appears.</p>

<p><span id="caseBreaks">Warning! <code class="language-plaintext highlighter-rouge">break</code> must be
explicit!</span></p>

<p>It’s very important to note that a <code class="language-plaintext highlighter-rouge">case</code> label
<strong>does not</strong> interrupt the flow of execution after a match has been
found. In other words, the case bodies are <strong>not</strong> like
<code class="language-plaintext highlighter-rouge">if</code>…<code class="language-plaintext highlighter-rouge">else</code> branches,
where execution leaves the overall statement when you reach the end of
the branch. Instead, they’re like <code class="language-plaintext highlighter-rouge">goto</code> labels,
where they just drop you into a linear sequence of code at a particular
point - and once you’re there, you’ll by default just keep going all the
way to the end of the <code class="language-plaintext highlighter-rouge">switch</code>, even if you
encounter other <code class="language-plaintext highlighter-rouge">case</code> labels along the way.</p>

<p>This is a feature of C that’s inherited by most C-like languages,
including TADS, and it catches a lot of people off-guard. Many
procedural languages outside the C-like family have similar “selection”
statements that <em>do</em> work like multi-branch if-then-else trees, and to
most people that’s the obvious, intuitive way of doing things. This is
probably one of the most counterintuitive aspects of C, and a common
pitfall for new C (and Java and TADS) programmers.</p>

<p>Fortunately, you <em>can</em> make each case block a self-contained little
branch, just like an
<code class="language-plaintext highlighter-rouge">if</code>…<code class="language-plaintext highlighter-rouge">else</code> - it’s
just that you have to do so <em>explicitly</em>. The way you do this is by
adding a <code class="language-plaintext highlighter-rouge">break</code> statement at the end of each
case body.</p>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch (obj.color)
    {
    case red:
      lambda = 700;
      break;

    case orange:
      lambda = 600;
      break;

    case yellow:
      lambda = 575;
      break;

    default:
      lambda = 0;
      break;
    }
</code></pre></div></div>

<p>Here, we’ve made each case body a self-contained branch by putting a
<code class="language-plaintext highlighter-rouge">break</code> statement at the end. A
<code class="language-plaintext highlighter-rouge">break</code> within a
<code class="language-plaintext highlighter-rouge">switch</code> body jumps to the next statement after
the end of the <code class="language-plaintext highlighter-rouge">switch</code>, so for each color case,
we’ll just set the wavelength variable and leave the
<code class="language-plaintext highlighter-rouge">switch</code>.</p>

<p>Note that we’ve even put a <code class="language-plaintext highlighter-rouge">break</code> at the very
end, as the last statement of the <code class="language-plaintext highlighter-rouge">default</code>
body. There’s no subtle magic behind this - it’s presence changes
nothing, exactly as you’d expect, since if we left it out we’d still
fall out of the end of the overall <code class="language-plaintext highlighter-rouge">switch</code> body
at that same point anyway. So why did we bother to write the
<code class="language-plaintext highlighter-rouge">break</code> there? There are a few reasons. One is
that it’s a good habit to just automatically end each case branch with a
<code class="language-plaintext highlighter-rouge">break</code>, since if you get into that habit you’re
less likely to miss one accidentally when it matters. Another is that it
makes the code look a little more consistent, since each branch has the
same form: <code class="language-plaintext highlighter-rouge">case</code>, code,
<code class="language-plaintext highlighter-rouge">break</code>. Perhaps the most important reason is
that it’s a little insurance in case we add another case label below the
<code class="language-plaintext highlighter-rouge">default</code> later on - at that point we might
forget that there’s a case above that we didn’t
<code class="language-plaintext highlighter-rouge">break</code> out of, so adding the
<code class="language-plaintext highlighter-rouge">break</code> now ensures that we won’t miss it then.</p>

<p>You might wonder how the designers of C ever came up with the crazy
“fall-through” feature in the first place. It’s probably a result of C’s
design as a thinly disguised version of assembly language. In assembler,
labels are just targets for “goto” jumps. The use of the label-like
syntax for the cases suggests that C’s designers conceived of “switch”
as a fancy “goto”. If you think of the case labels as just “goto”
targets, then, it makes a kind of sense that execution just plows on
through them rather than leaving the switch at the end of a case.</p>

<p>The fall-through behavior is handy for one thing, though. It lets you
easily share the same case body among multiple labels:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch (x)
    {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      "x is from 1 to 5\n";
      break;

    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      "x is from 6 to 10\n";
      break;
    }
</code></pre></div></div>

<p>This code works because the empty case bodies (for cases 1, 2, 3, etc.)
all “fall through” to the next executable statement, even though there
are intervening case labels.</p>

<p>On some occasions, it’s also convenient to take advantage of the
fall-through feature with actual executable code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch (x)
    {
    case 1:
      "one...";

    case 2:
      "x is one or two\n";
      break;
    }
</code></pre></div></div>

<p>In this case, we’re <em>intentionally</em> falling through from the “1” case to
the “2” case. There’s a little extra code we want to execute in the “1”
case, but then we want to proceed to the common handling for 1 and 2.
When you write code like this, it’s not a bad idea to comment that the
fall-through is intentional - if you don’t, and you come back to this
code after a couple of weeks, you might forget what you had in mind and
mistakenly think you forgot a <code class="language-plaintext highlighter-rouge">break</code>, and
mistakenly fix a non-mistake! So, something like this is a good idea:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    case 1:
      "one...";
      // FALL THROUGH...

    case 2:
      // etc...
</code></pre></div></div>

<p><span id="indentStyle">A note on indentation styles</span></p>

<p>There are basically two ways to indent <code class="language-plaintext highlighter-rouge">switch</code>
bodies. Some people like to indent the case labels one level in from the
<code class="language-plaintext highlighter-rouge">switch</code>, and then indent the statements in the
case bodies one level further:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch (x)
    {
      case 1:
        "One!";
        break;

      case 2:
        "Two!";
        break;

      default:
        "A million!";
        break;
    }
</code></pre></div></div>

<p>Other people, your author included, prefer to put the labels at the same
level as the <code class="language-plaintext highlighter-rouge">switch</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch (x)
    {
    case 1:
      "One!";
      break;

    case 2:
      // etc
    }
</code></pre></div></div>

<p>Both styles are common. I prefer the second because it makes for
slightly less indenting overall, which can be helpful in complex
functions; and because it treats the case labels consistently with
ordinary statement (“goto”) labels, which I like to “outdent” from the
code they’re labeling.</p>

<h3 id="goto"><span id="goto">goto</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">goto</code> statement transfers the execution
position directly to a labeled statement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goto label ;
</code></pre></div></div>

<p>The <span class="synPar">label</span> is the name of a statement label
defined elsewhere within the same function or method. The target label
can be within an enclosing code block, since statement labels are
visible within the entire containing function or method.</p>

<p>When a <code class="language-plaintext highlighter-rouge">goto</code> statement is executed, the VM
first executes the <code class="language-plaintext highlighter-rouge">finally</code> clause of each
enclosing <code class="language-plaintext highlighter-rouge">try</code> statement, working from the
innermost outward. It then jumps directly to the statement immediately
following the target label.</p>

<p>Almost anyone who’s had any exposure to programming in any language has
received the standard warnings about how bad
<code class="language-plaintext highlighter-rouge">goto</code> is. This is generally true:
<code class="language-plaintext highlighter-rouge">goto</code> is to be avoided. The problem with
<code class="language-plaintext highlighter-rouge">goto</code> is that it makes it extremely difficult
to grasp the flow of execution through a piece of code by making
arbitrary jumps. The sort of nested conditional and iteration structures
that modern languages offer
(<code class="language-plaintext highlighter-rouge">if</code>…<code class="language-plaintext highlighter-rouge">else</code>,
<code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">while</code>, and so
on) are much easier to comprehend at a glance, since their visual
structure on the page maps fairly directly to their code flow.
<code class="language-plaintext highlighter-rouge">goto</code> tends to ruin that clean visual structure
by scribbling arbitrary transfer vectors all over the page.</p>

<p>Even so, in C and C++, <code class="language-plaintext highlighter-rouge">goto</code> is occasionally
the clearest way to accomplish a task. The alternative is sometimes to
create a network of extra flags that shepherd the execution point out of
a series of nested loops and into a subsequent cleanup section. However,
the ability in TADS 3 to use labeled targets in
<code class="language-plaintext highlighter-rouge">break</code> and <code class="language-plaintext highlighter-rouge">continue</code>
statements largely eliminates even this type of situation, so justified
uses of <code class="language-plaintext highlighter-rouge">goto</code> in TADS 3 programs are rare
indeed.</p>

<h3 id="break"><span id="break">break</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">break</code> statement exits a given statement,
transferring control to the next statement after the given statement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>break [ label ]  ;
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">break</code> comes in two forms: with and without a
target label.</p>

<p>When no label is specified, <code class="language-plaintext highlighter-rouge">break</code> applies to
the nearest enclosing <code class="language-plaintext highlighter-rouge">for</code>,
<code class="language-plaintext highlighter-rouge">while</code>,
<code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code>, or
<code class="language-plaintext highlighter-rouge">switch</code> statement. There must be an enclosing
statement of one of these types in the current function or method; if
there isn’t, a compiler error results. Controls transfers to the
statement immediately after the end of the loop or
<code class="language-plaintext highlighter-rouge">switch</code> body.</p>

<p>When a label is specified, the <code class="language-plaintext highlighter-rouge">break</code> applies
to the labeled statement, which must enclose the
<code class="language-plaintext highlighter-rouge">break</code>. If the labeled statement doesn’t
enclose the <code class="language-plaintext highlighter-rouge">break</code>, a compiler error results.
If the target statement is a loop, control transfers to the statement
following the loop body. If the target is a compound statement (a group
of statements enclosed in braces), control transfers to the next
statement after the block’s closing brace.</p>

<p>Targeted <code class="language-plaintext highlighter-rouge">break</code> statements are especially
useful when you want to break out of a loop from within a nested
<code class="language-plaintext highlighter-rouge">switch</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    scanLoop:
      for (i = 1 ; i &lt; 10 ; ++i)
      {
        switch(val[i])
        {
        case '+':
          ++sum;
          break;

        case '-':
          --sum;
          break;

        case 'eof':
          break scanLoop;
        }
      }
</code></pre></div></div>

<p>The label is necessary in this case because the
<code class="language-plaintext highlighter-rouge">break</code> would, by default, only go as far as
exiting the <code class="language-plaintext highlighter-rouge">switch</code>. By specifying the label,
you can break all the way out of the enclosing
<code class="language-plaintext highlighter-rouge">for</code> loop.</p>

<p>Targeted break statements are also useful for breaking out of nested
loops:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    matchLoop:
      for (i = 1 ; i &lt;= val.length() ; ++i)
      {
        for (j = 1 ; j &lt; i ; ++j)
        {
          if (val[i] == val[j])
            break matchLoop;
        }
      }
</code></pre></div></div>

<p>A labeled <code class="language-plaintext highlighter-rouge">break</code> can break out of <em>any</em> block
of code - it doesn’t have to be a loop or a
<code class="language-plaintext highlighter-rouge">switch</code>. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    section1:
      {
        if (a == 1)
        {
          if (b == 2)
          {
            if (c == 3)
              break section1;

            // do some work...
          }

          // do something else...
        }

        // do some more stuff...
      }
      // that 'break section1' comes directly here
</code></pre></div></div>

<p>This is sometimes handy for error handling and the like, since it lets
you bypass a whole chunk of code by jumping directly out of the entire
labeled block.</p>

<h3 id="continue"><span id="continue">continue</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">continue</code> statement bypasses the remainder
of a loop body, and jumps directly to the start of the next iteration of
the loop.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>continue [ label ]  ;
</code></pre></div></div>

<p>If no label is specified, the <code class="language-plaintext highlighter-rouge">continue</code>
implicitly refers to the nearest enclosing
<code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">while</code>, or
<code class="language-plaintext highlighter-rouge">do...while</code> loop.</p>

<p>If a label is specified, the label must be associated with an enclosing
<code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">foreach</code>,
<code class="language-plaintext highlighter-rouge">while</code>, or <code class="language-plaintext highlighter-rouge">do</code>
statement. The target statement of the
<code class="language-plaintext highlighter-rouge">continue</code> is the labeled loop in this case.</p>

<p>Note that, in contrast to <code class="language-plaintext highlighter-rouge">break</code>, a
<code class="language-plaintext highlighter-rouge">continue</code> statement’s label <strong>must</strong> be
associated with a loop of some kind (<code class="language-plaintext highlighter-rouge">for</code>,
<code class="language-plaintext highlighter-rouge">foreach</code>, <code class="language-plaintext highlighter-rouge">while</code>, or
<code class="language-plaintext highlighter-rouge">do...while</code>).</p>

<p><code class="language-plaintext highlighter-rouge">continue</code> transfers control to the “next
iteration” of the targeted loop statement. The exact point depends on
the type of that loop:</p>

<ul>
  <li>If it’s a <code class="language-plaintext highlighter-rouge">for</code> loop, control transfers to the
“updater” expression. That is, immediately after the
<code class="language-plaintext highlighter-rouge">continue</code> is executed, the
<code class="language-plaintext highlighter-rouge">for</code> evaluates its “updater” expression, then
then evaluates its “condition” expression and uses the result to
determine whether or not to perform another iteration of the loop
body.</li>
  <li>If it’s a <code class="language-plaintext highlighter-rouge">foreach</code> loop, the next element of
the Collection is fetched into the iteration variable, and control is
transferred back to the top of the loop body (unless the Collection
has been exhausted, in which case the loop terminates as normal).</li>
  <li>If it’s a <code class="language-plaintext highlighter-rouge">while</code> or
<code class="language-plaintext highlighter-rouge">do</code>…<code class="language-plaintext highlighter-rouge">while</code> loop,
control transfers to the condition evaluation. That is, immediately
after the <code class="language-plaintext highlighter-rouge">continue</code> statement, the loop
evaluates its condition expression, and uses the result to determine
whether or not to perform another iteration of the loop body.</li>
</ul>

<p>Here’s an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 0 ; i &lt; 10 ; ++i)
    {
      "i = &lt;&lt;i&gt;&gt;\n";
      if (i &lt; 5)
        continue;

      "*** i is at least 5!\n";
    }
</code></pre></div></div>

<h3 id="throw"><span id="throw">throw</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">throw</code> statement “throws an exception.”
That is, given an Exception object, the statement transfers control to
the nearest enclosing <code class="language-plaintext highlighter-rouge">catch</code> handler for that
class of Exception.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>throw expression ;
</code></pre></div></div>

<p>The <span class="synPar">expression</span> is most often of the form
<code class="language-plaintext highlighter-rouge">new E()</code>, where <code class="language-plaintext highlighter-rouge">E</code> is
some Exception subclass. However, any expression that yields an
Exception instance is valid here, and it’s frequently useful to use
<code class="language-plaintext highlighter-rouge">throw</code> with a local variable that contains a
previously caught Exception instance, or simply a static Exception
instance.</p>

<p>Refer to the section on <a href="except.html">exception handling</a> for more
details on <code class="language-plaintext highlighter-rouge">try</code> and
<code class="language-plaintext highlighter-rouge">throw</code>.</p>

<h3 id="try"><span id="try">try</span></h3>

<p>The <code class="language-plaintext highlighter-rouge">try</code> statement sets up an exception handler
for the duration of the enclosed block of code, which is referred to as
the code “protected” by the <code class="language-plaintext highlighter-rouge">try</code>. This allows
you to catch and handle selected exceptions that are thrown from within
the protected code, or from any code that it calls via function and
method calls.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>try
{
  protectedCode
}
catch ( exceptionClass exceptionLocal )
{
  handlerCode
}
catch ( exceptionClass exceptionLocal )
{
  handlerCode
}
finally
{
  finallyCode
}
</code></pre></div></div>

<p>The <span class="synPar">protectedCode</span> consists of any number of
statements. This is the code that the <code class="language-plaintext highlighter-rouge">try</code>
protects: if a handled exception is thrown from within this code or any
other functions or methods it calls, control is transfered to the first
statement of the body of the first <code class="language-plaintext highlighter-rouge">catch</code>
clause whose <span class="synPar">exceptionClass</span> equals or is a
superclass of the thrown exception.</p>

<p>A <code class="language-plaintext highlighter-rouge">try</code> can have zero or more
<code class="language-plaintext highlighter-rouge">catch</code> clauses.</p>

<p>Within each <code class="language-plaintext highlighter-rouge">catch</code> clause, the
<span class="synPar">exceptionClass</span> is the name of an Exception
subclass, indicating which type of exception(s) this clause handles. The
<span class="synPar">exceptionLocal</span> is a symbol that will be
defined as a new local variable, which is scoped to the
<code class="language-plaintext highlighter-rouge">catch</code> clause. (That is, the variable will be
visible only within that <code class="language-plaintext highlighter-rouge">catch</code> clause, and
hides any variable of the same name that’s defined in any enclosing
scope.) The <span class="synPar">handlerCode</span> is any number of
statements; this block of code comprises the handler for the specified
exception.</p>

<p>The <code class="language-plaintext highlighter-rouge">finally</code> clause is optional. If it’s
present, only one is allowed, and it must follow all of the
<code class="language-plaintext highlighter-rouge">catch</code> clauses. The
<span class="synPar">finallyCode</span> consists of any number of
statements; this block of code comprises the “finally” handler for the
protected code.</p>

<p>When an exception occurs within the protected code, the VM searches the
<code class="language-plaintext highlighter-rouge">try</code> statement for a
<code class="language-plaintext highlighter-rouge">catch</code> handler that “matches” the exception
actually thrown. A handler matches the thrown exception is the exception
equals the <span class="synPar">exceptionClass</span> named in the
handler, or the thrown exception is a subclass of the named class. The
VM searches the <code class="language-plaintext highlighter-rouge">catch</code> clauses in order,
starting at the first (top) handler:</p>

<ul>
  <li>If the VM finds a matching <code class="language-plaintext highlighter-rouge">catch</code> handler, it
stores a reference to the thrown exception in the
<span class="synPar">exceptionLocal</span> local variable named in
that <code class="language-plaintext highlighter-rouge">catch</code> clause, then transfers control to
the first statement of the <span class="synPar">handlerCode</span> of
that <code class="language-plaintext highlighter-rouge">catch</code> clause. At this point, the VM
considers the exception completely handled.</li>
  <li>If the VM fails to find a matching <code class="language-plaintext highlighter-rouge">catch</code>
handler after searching all of the <code class="language-plaintext highlighter-rouge">catch</code>
clauses, it “re-throws” the exception. This means that it looks for
the next enclosing <code class="language-plaintext highlighter-rouge">try</code> block within the
enclosing method, and failing that looks for the next enclosing block
in the calling method, and that method’s caller, and so on. Upon
finding the enclosing <code class="language-plaintext highlighter-rouge">try</code>, the VM repeats
the <code class="language-plaintext highlighter-rouge">catch</code> search with the new
<code class="language-plaintext highlighter-rouge">try</code>.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">finally</code> block, if specified, contains code
that will be executed when control transfers out of the protected
<code class="language-plaintext highlighter-rouge">try</code> code, <em>no matter how that transfer
occurs.</em> Control can transfer out of the protected
<code class="language-plaintext highlighter-rouge">try</code> code due to:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">goto</code> that targets a label outside of the
protected code</li>
  <li>A <code class="language-plaintext highlighter-rouge">break</code> that leaves the protected code</li>
  <li>A <code class="language-plaintext highlighter-rouge">continue</code> that resumes a loop enclosing the
protected code</li>
  <li>A <code class="language-plaintext highlighter-rouge">return</code> from within the protected code</li>
  <li>A <code class="language-plaintext highlighter-rouge">throw</code> from within the protected code</li>
  <li>Simply “falling off the end” of the protected code</li>
</ul>

<p>If a <code class="language-plaintext highlighter-rouge">catch</code> handler catches an exception thrown
within the protected code, the <code class="language-plaintext highlighter-rouge">finally</code> clause
will <em>still</em> run - as promised, it <em>always</em> runs when control exits the
<code class="language-plaintext highlighter-rouge">try</code>, no matter how. In this case, the
<code class="language-plaintext highlighter-rouge">finally</code> clause will run when control transfers
<em>out</em> of the <code class="language-plaintext highlighter-rouge">catch</code> handler. Control can
transfer out of the <code class="language-plaintext highlighter-rouge">catch</code> handler in any of
the ways listed above for the main protected code; the
<code class="language-plaintext highlighter-rouge">finally</code> will be invoked at that time for any
of those modes of egress.</p>

<p>For more details on <code class="language-plaintext highlighter-rouge">try</code> and
<code class="language-plaintext highlighter-rouge">throw</code>, refer to the section on <a href="except.html">exception
handling</a>.</p>

<h2 id="notes-for-tads-2-users"><span id="tads2">Notes for TADS 2 users</span></h2>

<p>TADS 2 users should note some important syntax changes from the old
language:</p>

<ul>
  <li>The TADS 2 function definition syntax is no longer supported. Instead,
TADS 3 uses a syntax that’s much like Java’s or C’s. This makes the
language more internally consistent.</li>
  <li>Method definitions are also slightly different from TADS 2’s syntax.
In particular, the <code class="language-plaintext highlighter-rouge">=</code> (equals sign) that came
between a method’s parameter list and its body is no longer allowed.
This makes method definitions look much more like they do in Java and
C++.</li>
</ul>

<p>TADS 3 lifts a number of restrictions that TADS 2 imposed. Some of the
more important ones:</p>

<ul>
  <li>In TADS 3, forward function declarations are never required. The
compiler processes the entire program’s source code before resolving
symbols, so it looks ahead by itself and requires no explicit forward
declarations.</li>
  <li>TADS 3 lets you use empty parentheses to call a method that takes no
parameters. This is exactly equivalent to calling the method with no
argument list (that is, no parentheses) at all.</li>
  <li>You can define local variables anywhere in a code block in TADS 3.
That is, a <code class="language-plaintext highlighter-rouge">local</code> statement can go anywhere a
regular executable statement can go. The TADS 2 restriction, that
<code class="language-plaintext highlighter-rouge">local</code> statements could only go at the top of
a code block, no longer applies.</li>
</ul>

<hr />

<p><em>TADS 3 System Manual</em><br />
<a href="toc.html" class="nav">Table of Contents</a> |
<a href="langsec.html" class="nav">The Language</a> &gt; Procedural Code<br />
<span class="navnp"><a href="expr.html" class="nav"><em>Prev:</em> Expressions and
Operators</a>    
<a href="optparams.html" class="nav"><em>Next:</em> Optional
Parameters</a>     </span></p>


</main>
<footer id="footer">
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>

<script>
    if(window.location !== window.top.location) {
        let header = document.getElementById('header');
        let footer = document.getElementById('footer');
        header.remove();
        footer.remove();
    }
</script>