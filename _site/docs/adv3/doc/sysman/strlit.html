<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title></title>
    <meta property="og:title" content=
    "">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header id="header"><div class="header-search">
    <form class="header-search-form" action="/search" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<p><img src="topbar.jpg" data-border="0" />
<a href="toc.html" class="nav">Table of Contents</a> |
<a href="langsec.html" class="nav">The Language</a> &gt; String Literals<br />
<span class="navnp"><a href="types.html" class="nav"><em>Prev:</em> Fundamental Datatypes</a>
    <a href="enum.html" class="nav"><em>Next:</em> Enumerators</a>    
</span></p>
<h1 id="string-literals">String Literals</h1>

<p>TADS is a language for Interactive Fiction, and IF is made mostly of
text. Naturally, text is a big area of specialization for TADS, where
the language breaks from its C and Java roots. This chapter describes
the special string literal features in TADS.</p>

<h2 id="the-basics">The basics</h2>

<p>A string literal is a block of text enclosed in quote marks - either
single quotes or double quotes, depending on the kind of string, which
we’ll come to shortly.</p>

<p>Within the quotes, you can write <em>almost</em> any text. There are a few
<a href="#specials">special codes</a> that TADS interprets specially, which we’ll
discuss later; but apart from those, text within a string is just
literal text for TADS to store and/or display.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "This is a string in double quotes."
    'This is a string in single quotes.'
</code></pre></div></div>

<p>Unlike most other C-like languages, TADS allows a string to continue
across multiple lines without any special syntax. A TADS string starts
with a quote mark and keeps going until the next instance of the same
kind of quote mark.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "This is a string.  A string can go on for
    any number of lines... it keeps going until
    we come to another copy of the same quote
    mark that started the string, which we're
    finally coming to... now!"
</code></pre></div></div>

<p>When a string is broken across lines, TADS treats it as though it were
written on one line, with a space character in place of each line break.</p>

<p>Note in the example above that we’re free to use the <em>other</em> kind of
quote within a string. If a string starts with a double quote mark, we
can freely use single quotes within the string - they just count as
ordinary text, because the string goes on until we come to another copy
of the same mark that started the string.</p>

<p>But what if you want to use a double quote mark within a double-quoted
string, or single within single? You do this by “escaping” the quote
mark, which you do by putting a backslash character in front of it. (The
backslash is this one: “\. It looks like a plank that’s leaning to the
left, and left equals backwards if you think about it in terms of
left-to-right reading order. Backwards slash → backslash. “Escaping,” by
the way, means that you’re removing the special meaning of the quote
mark as the end-of-string marker, and turning it into an ordinary
literal character within the string.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Bob said, \"Well, this looks like a quote
    within a quote!\""

    'It\'s less obvious that you need the escapes
    here, isn\'t it?'
</code></pre></div></div>

<p>Note in the latter example how you need to escape apostrophes within
single-quoted strings. TADS would otherwise think an apostrophe is the
matching single quote that ends the string.</p>

<h2 id="two-kinds-of-string-literal">Two kinds of string literal</h2>

<p>TADS has two different types of string literal, which are named
according to the kind of quote mark that encloses them in the program
source code: <em>single-quoted strings</em> and <em>double-quoted strings</em>. The
names might be a bit awkward, but they make up for it by being obvious,
in that you can tell the type of a string just by looking at its
surrounding quote marks.</p>

<p>The functional difference isn’t at all obvious, though. It’s certainly
not something you could guess looking at the syntax. It’s not even
something you’d guess from other programming languages. So it’s
something we need to explain.</p>

<p>Here’s the difference:</p>

<p>A string in <em>single quotes</em> is a string “value”: a piece of data that
you can assign to a variable, pass as a function argument, chop up with
substring operators, combine with concatenation operators, and do all
the other things that you can do with strings in other programming
languages.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // assign a string value to the variable 'str'
    local str = 'This is a string value, because it\'s in single quotes.';

    // now we can manipulate this string value with method calls, etc
    str = str.substr(5);
</code></pre></div></div>

<p>A string in <em>double quotes</em> is a concise way of saying “Print this now!”
A double-quoted string <em>isn’t</em> a value. You can’t assign it to a
variable or otherwise manipulate it. Whenever the current execution
point reaches a double-quoted string, TADS simply prints out the string,
and moves on to the next line of code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "This string prints itself out as soon as it's executed. You can't
    assign it to a variable - it has no value to manipulate.";
</code></pre></div></div>

<h2 id="triple-quotes"><span id="tripleQuotes">Triple quotes</span></h2>

<p>Single quotes, double quotes… and now triple quotes?</p>

<p>Don’t worry: this isn’t a third type of string. It’s just another way of
writing the first two kinds.</p>

<p>A triple-quoted string is a string surrounded by <em>three copies</em> of its
quote mark on each side - three quote marks at the beginning, and three
more at the end. You might wonder why you’d want to use three quotes
when one would do. What you gain is the ability to use the quote mark
character freely as literal text within the string, without worrying
about “escaping” it with a backslash. The compiler knows that the string
doesn’t end until it sees the closing triplet, so you can safely use the
quote mark individually (or even in pairs) within the string without
creating any confusion.</p>

<p>A few other C-like languages have adopted similar triple-quote schemes,
since it’s more convenient and nicer looking for strings that contain
quote marks as part of their literal text. This is a particularly common
occurrence in an interactive fiction language like TADS, where many
strings contain passages of story text.</p>

<p>Here’s a simple example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = """The sign reads "Beware of Backslash!""""
</code></pre></div></div>

<p>This example is actually a little less simple than it looks. It happens
to illustrates a subtle (and nice) feature of triple quotes. Note how
the string ends with <em>four</em> quote marks. Triple-quoted strings that end
with <em>N</em>&gt;3 consecutive quote marks treat the first <em>N</em>-3 quotes as part
of the string, and the last three as the delimiter. So when printed,
this message looks just as you’d want it to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    The sign reads "Beware of Backslash!"
</code></pre></div></div>

<p>Here’s how you write a string that displays 10 quote marks in a row:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    """""""""""""""";
</code></pre></div></div>

<p>That’s three for the opening delimiter, three for the ending delimiter,
and ten quotes for display. It’s a little strange looking, but it’s a
heck of a lot better than <code class="language-plaintext highlighter-rouge">"\"\"\"\"\"\"\"\"\"\""</code>, which looks more
like an attempt at an ASCII graphic.</p>

<p>You can use triple-quoting with single- and double-quoted strings, and
in both cases the type of quote character determines the type of string
it is, just as with ordinary once-quoted strings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   local s = '''This is a 'string value', since it's in single quotes.''';
   """This string is printed out "immediately", since it's in double quotes.""";
</code></pre></div></div>

<p>There’s one other special feature to be aware of. Most people will
probably never encounter this, because it gets into something that
doesn’t tend to come up naturally in story text. But this is a
programming language, after all, so we have to consider the weird cases,
too. The question is what happens if you want to write, say, five quotes
in a row as literal text within a triple-quoted string? We’ve already
seen how to write a bunch of quotes at the <em>end</em> of the string: write
the quotes and then just add three more as the ending delimiter. But
what about in the middle of the string?</p>

<p>In this situation we reluctantly have to fall back on the backslash,
since there’s just no other way that the compiler could know that you
intend for the string to continue after the glob of quotes. But here’s
where the special feature comes in: you only have to use one backslash
for a whole row of quotes. When the compiler encounters a backslash
followed by a quote within a triple-quoted string, it applies the
backslash to the entire run of consecutive quotes that follow the
backslash.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    """For whatever reason, I want to write a \"""""quintuple quoted\"""""
    string within this \"""triple quoted\""" string!""";
</code></pre></div></div>

<p>Other than the tripled delimiters and the treatment of escaped quote
runs, triple-quoted strings work exactly like their ordinary
counterparts. In particular, there’s no difference in how they behave at
run-time, and no difference in how embedded &lt;&lt; &gt;&gt; expressions are
handled.</p>

<h2 id="line-breaks">Line breaks</h2>

<p>We mentioned earlier that the compiler treats line breaks in strings as
though they were spaces. Let’s look at that in more detail.</p>

<p>By default - and we’ll see in a moment that there are some other options
apart from the default - when the compiler encounters a line break
within a string, it does two things:</p>

<ul>
  <li>It removes the line break and replaces it with a space character,
making it seem as though you had written the whole string on one line.</li>
  <li>It deletes all of the spaces at the beginning of the next line.</li>
</ul>

<p>The reason for deleting the spaces at the start of the next line after a
line break is that most people like to indent their code to make it more
readable. The compiler assumes that all of the spaces at the start of a
line are for indentation, purely for code readability, and aren’t really
part of the string.</p>

<p>In some cases, you might want a line break and the subsequent
indentation to be part of the string. For example, if you’re writing
preformatted display code for an HTML <code class="language-plaintext highlighter-rouge">\&lt;PRE\&gt;</code>
section, you might want to use spacing at the start of a line for
indentation in the displayed text. You can do this by writing an
explicit <code class="language-plaintext highlighter-rouge">\n</code> (newline) sequence at the end of
each line, just before the line break. When the compiler sees a line
ending in <code class="language-plaintext highlighter-rouge">\n</code>, it keeps all of the spacing at
the start of the next line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    f()
    {
        local a = 'test\n
         string';
    }
</code></pre></div></div>

<p>Because the first line of the string ends in an explicit
<code class="language-plaintext highlighter-rouge">\n</code>, the compiler preserves the spaces at the
start of the second line, so the string is stored as though you had
written <code class="language-plaintext highlighter-rouge">local a =
'test\n</code><code class="language-plaintext highlighter-rouge">string';</code>.</p>

<p>What we’ve seen so far is the compiler’s default handling. In addition
to this default behavior, there are two other “modes” that do slightly
different things with line breaks.</p>

<p>The default mode that we’ve been talking about so far is called
“collapse” mode, because the compiler collapses all of the spacing at
each line break into a single space character. You don’t have to do
anything special to select this mode, since it’s the default, but you
can also turn it on explicitly by adding this to your source file, on a
line by itself:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #pragma newline_spacing(collapse)
</code></pre></div></div>

<p>Once you set a newline spacing mode, it sticks until the end of the
source file, or until you change it with another #pragma. If you set
the mode in an included file, it automatically returns to the enclosing
file’s mode at the end of the included file, so you don’t have to worry
when using #include that the file will change the mode on you.</p>

<p>The second newline spacing option is “delete” mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #pragma newline_spacing(delete)
</code></pre></div></div>

<p>In delete mode, the compiler entirely deletes each line break, and all
of the indentation on the next line. The result is that the two lines
surrounding a line break are mashed together with no spacing at all
between them. Why would you want this? In some languages, especially
ideographic languages such as Chinese, it’s standard to write text with
no spacing between words. The “collapse” mode is inconvenient for
writing long strings in this kind of language because it introduces
unwanted spacing between characters wherever you happen to insert a line
break in the source code just to keep line lengths within the page
boundaries. “Delete” mode is good for this type of language because it
lets you break up long lines as needed, but joins everything together
without any unwanted extra spaces when the text is actually displayed at
run-time.</p>

<p>Remember the trick we saw earlier with writing
<code class="language-plaintext highlighter-rouge">\n</code> at the end of a line to preserve exact
spacing? That works the same way in delete mode.</p>

<p>The final mode is called “preserve” mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #pragma newline_spacing(preserve)
</code></pre></div></div>

<p>In preserve mode, the compiler keeps line breaks and whitespace intact,
exactly as written in the source code. Each line break is replaced by a
<code class="language-plaintext highlighter-rouge">\n</code> (newline) character, and any indentation at
the start of the next line is preserved exactly as written. Preserve
mode is useful when you want precise control over the
character-by-character contents of a string, such as when you’re writing
text to a file, or when you’re writing an HTML
<code class="language-plaintext highlighter-rouge">\&lt;PRE\&gt;</code> section.</p>

<h2 id="regular-expression-literals">Regular expression literals</h2>

<p>There’s another bit of syntax that looks very similar to the string
literal syntax, but doesn’t define an ordinary string. You can define a
static <a href="rexpat.html">RexPattern</a> object, which represents a <a href="regex.html">regular
expression</a>, using the “R” string syntax:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local r = R'%w+';
</code></pre></div></div>

<p>The regular expression literal syntax consists of a capital “R” followed
immediately (with no intervening spaces) by an open quote. Single and
double quotes are interchangeable for regular expression literals.</p>

<p>For more details, see <a href="rexpat.html#rexlit">regular expression literals</a>
in the RexPattern section.</p>

<h2 id="plain-vs-typographical-quotes">Plain vs. typographical quotes</h2>

<p>Before we go on, there’s a common point of confusion that we should
address. Most computer fonts include a whole raft of different quote
marks, but when you’re writing TADS source code, it’s important that you
only use plain, “straight” quotes to mark string literals.</p>

<p>The “straight quotes” are so called because their appearance in most
fonts is straight up and down, without any tilt to the left or right.
They’re <em>usually</em> the quotes you get when you press this key (on a
standard US QWERTY keyboard, at least):</p>

<p><img src="quotekey.jpg" style="margin-left:3em;" /></p>

<p>The thing that’s confusing is that most computer fonts include an
additional set of quotes known as “curly” or “typographical” quotes.
These are split into left and right versions, which curl or tilt in
opposite directions. The visual difference is subtle, but it helps to
see the two kinds side by side:</p>

<p><img src="quotemarks.jpg" style="margin-left:3em;" /></p>

<p>Be sure that you always enclose strings in straight quotes. As we said
earlier, that’s <em>usually</em> the kind of quote that you get when you press
the plain-quote key. However, many word processing programs have a
“smart quotes” mode that automatically substitutes curly quotes when you
press that key. If you’re using that kind of program, you’ll need to
turn off the “smart quotes” mode while writing TADS code.</p>

<p>Not all fonts show plain quotes as <em>exactly</em> straight up and down. Some
fonts show a slight tilt even for plain quotes, for aesthetic value.
That’s purely visual, of course, and it doesn’t matter to TADS since
TADS doesn’t know or care what font you’re using in your text editor. If
you can’t tell for sure which quote is which, one trick to try is to
change your editor program’s font to a monospaced, “typewriter style”
font such as Courier. That should make it easy to distinguish the
different quote types visually. Once you’ve confirmed that you’re using
the correct quotes, you can switch back to whatever font you prefer.</p>

<p>Note that it’s okay to use curly quotes <em>within</em> a string, since any
text is allowed there. TADS is only picky about the quotes that
<em>surround</em> a string (or “delimit” it, in techno jargon).</p>

<h2 id="special-characters-in-strings"><span id="specials"></span>Special characters in strings</h2>

<p>Earlier, we mentioned that there are a few special codes that TADS
interprets within strings. Let’s look at the full list.</p>

<p>The first is the quote marks themselves. The quote mark that opens a
string is also the character that ends the string, so if you want to use
that quote mark within the string you need to “escape” it by putting a
backslash “\ in front of it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Bob said, \"Remember those backslashes!\""
</code></pre></div></div>

<p>(Of course, no backslash is needed within <a href="#tripleQuotes">triple-quoted</a>
strings, unless you want to use three or more of the quote marks in a
row.)</p>

<p>The second is the <a href="#embeddings">embedded expression</a> syntax. This
consists of two less-than signs “<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code>”,
followed by an expression to evaluate, followed by two greater-than
signs “<code class="language-plaintext highlighter-rouge">\&gt;\&gt;</code>”. TADS interprets any
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> sequence in a string as the start of an
embedding, so if you actually want your string to literally include two
less-than signs in a row, you must escape one of them (either one will
do).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    'The sign reads "\&lt;&lt;Danger!&gt;&gt;"'
</code></pre></div></div>

<p>The third is the backslash character itself. Since it has this special
meaning of escaping other special characters, it is itself a special
character. Naturally, then, if you want to use a backslash literally in
a string, you escape it by adding <em>another</em> backslash in front of it. In
other words, you write two backslashes in a row to indicate one literal
backslash.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "This is what a backslash looks like: \\."
</code></pre></div></div>

<p>In addition to escaping special characters, the backslash is also used
to generate additional special characters. For example,
<code class="language-plaintext highlighter-rouge">\n</code> represents a newline character. A full list
of these special combinations is <a href="#backslash">below</a>.</p>

<p>Those are all of the characters that affect how the <em>compiler</em> reads
your string contents: quotes, <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> sequences,
and backslashes. Everything else, the compiler reads literally, and
stores in your compiled program as you wrote it.</p>

<p>Once your program is running, though, there’s another layer of string
interpretation that you need to be aware of. Whenever you <em>display</em> a
string, by printing it to the console for the user to see, the TADS
<em>interpreter</em> processes any HTML markups in the printed text. The
compiler simply ignores HTML codes, leaving it to the interpreter to
process them.</p>

<p>There are two kinds of HTML markups: tags and entities.</p>

<p>An HTML tag is a sequence enclosed in <code class="language-plaintext highlighter-rouge">\&lt;angle
brackets\&gt;</code>, such as <code class="language-plaintext highlighter-rouge">\&lt;B\&gt;</code> or
<code class="language-plaintext highlighter-rouge">\&lt;A HREF="link"\&gt;</code>. (Note that “angle brackets”
is just another term for less-than and greater-than signs. They’re
exactly the same characters, <em>not</em> a new kind of quote mark.) In TADS,
HTML tags are mostly used to control text formatting. TADS uses most of
the standard HTML 3.2 tags, which you can find more about in any HTML
reference. Some common tags that TADS recognizes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\&lt;b\&gt;text\&lt;/b\&gt;</code> - show <em>text</em> in boldface</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;i\&gt;text\&lt;/i\&gt;</code> - show <em>text</em> in italics</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;u\&gt;text\&lt;/u\&gt;</code> - show <em>text</em> underlined</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;a href="URL"\&gt;text\&lt;/a\&gt;</code> - show <em>text</em>
hyperlinked to <em>URL</em></li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;font name="Arial"\&gt;text\&lt;/font\&gt;</code> - show
<em>text</em> in the typeface Arial</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;font color="red"\&gt;text\&lt;/font\&gt;</code> - show
<em>text</em> in red</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;font size=4\&gt;text\&lt;/font\&gt;</code> - show <em>text</em> a
little larger than normal</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;font size=7\&gt;text\&lt;/font\&gt;</code> - show <em>text</em>
in very large type</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;body bgcolor="gray"\&gt;</code> - change the window
background color to gray</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;h1\&gt;heading\&lt;/h1\&gt;</code> - display <em>heading</em> as
a large section heading</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;h2\&gt;heading\&lt;/h2\&gt;</code> - display <em>heading</em> as
a sub-heading</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;h3\&gt;heading\&lt;/h3\&gt;</code> - display <em>heading</em> as
a sub-sub-heading</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;font bgcolor="blue"\&gt;text\&lt;/font\&gt;</code> - show
<em>text</em> with a blue background</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;center\&gt;text\&lt;/center\&gt;</code> - show <em>text</em>
centered in the window</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;img src="picture.jpg"\&gt;</code> - display an image</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;sound src="music.mp3"\&gt;</code> - start playing
back an audio file</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;p\&gt;</code> - start a new paragraph</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;br\&gt;</code> - show a line break</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;ul\&gt; \&lt;li\&gt;list item \&lt;li\&gt;list item
\&lt;/ul\&gt;</code> - show a bullet list</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;table\&gt;...\&lt;/table\&gt;</code> - format a table</li>
</ul>

<p>An HTML entity is spelled-out version of a single character. Entities
are written as <code class="language-plaintext highlighter-rouge">&amp;name;</code> - ampersand, name,
semicolon. For example, <code class="language-plaintext highlighter-rouge">&amp;lt;</code> is the entity
markup for a less-than sign, <code class="language-plaintext highlighter-rouge">&amp;gt;</code> is a
greater-than sign, and <code class="language-plaintext highlighter-rouge">&amp;amp;</code> is an ampersand.
(You can check any HTML reference for a full list.)</p>

<p>The <code class="language-plaintext highlighter-rouge">&amp;</code> is what triggers an entity
interpretation, so if you want to use an <code class="language-plaintext highlighter-rouge">&amp;</code>
literally in displayed text, you need to spell it out as
<code class="language-plaintext highlighter-rouge">&amp;amp;</code>. (Were you thinking of using a
backslash? Remember, the backslash only escapes characters at the
compiler level. An <code class="language-plaintext highlighter-rouge">&amp;</code> in a string isn’t special
to the compiler - it’s only special to the HTML display engine. To sneak
special characters past the HTML display system, you have to use HTML
entities, not backslashes.)</p>

<h3 id="compiler-vs-html-interpretation">Compiler vs. HTML interpretation</h3>

<p>As we’ve just seen, there are two quite separate stages where TADS
interprets the contents of your strings. For the most part you won’t
find yourself worrying about the details. On occasion, though, it can
save you a ton of hair-pulling if you have a good understanding of
what’s really going on as a string makes its way from your source code
file, into the compiled program’s memory at run-time, and finally out to
the display.</p>

<p>There are two key things to know. The first one is how a given string is
actually <strong>stored</strong> in memory. The second is how a given stored string
is <strong>displayed</strong> when printed.</p>

<p>The <em>compiler</em> special characters - quotes, backslashes, and
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> sequences - affect what’s <em>stored</em> in
your compiled program. The <em>HTML</em> sequences only affect what’s
<em>displayed</em> on the user’s screen at run-time. The compiler doesn’t do
anything to interpret HTML; it simply copies HTML markups
character-for-character into the compiled program, where they’re stored
as part of the text in a string. There, the power of the HTML lies
dormant, until the string is printed to the screen.</p>

<p>Here’s an example showing the three stages of a string’s lifecycle: the
way it appears in the original source code; the way it’s stored in the
compiled “.t3” file (which is the same way it’s loaded into memory when
the program runs); and the way it looks when the user sees it on the
display. (Note that this is just a program fragment - it’s not a
complete working program.)</p>

<p><img src="stringexample1.jpg" style="margin-left:3em;" /></p>

<p>It’s worth taking a few minutes to make sure you understand the various
pieces of the picture.</p>

<p>First, note how the backslashes in the source code disappear in the
compiled version. This is because the compiled version stores strings as
objects; they no longer need quotes to mark where they start and stop,
so the embedded quotes can be stored directly, without escapes. The same
applies to the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> sequence in the
“<code class="language-plaintext highlighter-rouge">\&lt;\\Danger\&gt;\&gt;</code> string: the backslash
disappears from the stored copy because the compiler has finished
interpreting it, making it unnecessary to escape the compiler-only
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> sequence.</p>

<p>The removal of the backslashes is important when you manipulate a string
in the program. <code class="language-plaintext highlighter-rouge">x.substr(2, 1)</code> extracts the
second character of the string. Since the backslash is no longer there,
the second character is now the second <code class="language-plaintext highlighter-rouge">\&lt;</code>
character.</p>

<p>Second, observe that the HTML sequences are <em>not</em> removed from the
strings or translated in any way. They’re just copied
character-for-character to the compiled version. The
<code class="language-plaintext highlighter-rouge">&amp;lt;</code> entities, for example, are actually
stored as the chararacters <code class="language-plaintext highlighter-rouge">&amp;</code>
<code class="language-plaintext highlighter-rouge">lt</code>
<code class="language-plaintext highlighter-rouge">;</code> - they’re not converted to
<code class="language-plaintext highlighter-rouge">\&lt;</code> characters. Note also that your program
code can tell the difference: when you compare a stored
<code class="language-plaintext highlighter-rouge">\&lt;</code> character to the string
<code class="language-plaintext highlighter-rouge">'\&lt;'</code>, you get a match. When you compare it to
the string <code class="language-plaintext highlighter-rouge">'&amp;lt;'</code>, it <em>doesn’t</em> match, because
the latter is actually stored as <code class="language-plaintext highlighter-rouge">&amp;</code>
<code class="language-plaintext highlighter-rouge">lt</code>
<code class="language-plaintext highlighter-rouge">;</code> and thus doesn’t match a string stored as
<code class="language-plaintext highlighter-rouge">\&lt;</code>.</p>

<p>Third, you can see that when the running program writes out any of these
strings to the display, the HTML is finally interpreted. The
<code class="language-plaintext highlighter-rouge">&amp;lt;</code> sequences finally turn into
<code class="language-plaintext highlighter-rouge">\&lt;</code> characters, and the tags such as
<code class="language-plaintext highlighter-rouge">\&lt;B\&gt;</code> serve their control function rather than
appearing as literal text.</p>

<p>Displaying a string doesn’t change the stored copy of the string, of
course. The display process is strictly one-way, from the program memory
to the display window. A string stored in memory still has its original
HTML markups after it’s displayed. That way if you print the string
again, you get the same display result.</p>

<h2 id="embedded-expressions"><span id="embeddings"></span>Embedded expressions</h2>

<p>The “interactive” part of interactive fiction usually means that
conditions in the game world change as the player progresses through the
game. That game world is presented through the text the program
displays, so as the world evolves, so must the text. This makes it
especially important to have a convenient way to write text that varies
according to the world model.</p>

<p>In most programming languages, the standard approach to write varying
text is to build it up by combining some static fragments with others
that change depending on the current state of the game. To take a simple
example, suppose we want to describe a door that can be opened and
closed. Most of the description never changes, but the part that
mentions the current state of the door does. So our first attempt at a
description procedure might look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "It's a sturdy-looking oak door, ten feet high. A weathered
    wrought iron knocker is centered just above your eye level.
    The door ";
    if (door.isOpen)
      "stands open.";
    else
      "is firmly shut.";
</code></pre></div></div>

<p>That works fine, but it takes a fair amount of typing. And if you
consider the number of messages in a typical game that might need the
same treatment, it can add up to <em>a lot</em> of typing. It’s also a bit hard
to read, since the string elements are so disjoint, broken up as they
into several statements. And if you’re writing this as an object
property value, it adds even more to the required syntax, since you have
to go from a plain property definition like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "It's a sturdy-looking oak door, ten feet high."
</code></pre></div></div>

<p>…to a method-style definition, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc { "It's a sturdy-looking oak door, ten feet high."; }
</code></pre></div></div>

<p>It’s not a lot of extra syntax, but again, in a typical game you’ll be
writing these sorts of snippets many times, so they add up.</p>

<p>What’s more, some descriptions can get quite a lot more complex than our
door example. Room descriptions in particular tend to have lots of
moving parts. Think about how complex this approach would get if you had
five or six varying passages interposed.</p>

<p>This is where embedded expressions come in. Expression embedding (some
programming languages call it “interpolation”) is a special syntax that
lets you insert variables, expressions, and even control flow code,
right into a string. This can be much more succinct than writing it out
as a series of separate statements, as we did above.</p>

<p>The embedding syntax is simple. Anywhere in a string, you can write
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> - two less-than signs - to drop into
“expression mode.” At that point you can write any expression. An
expression can be the name of a local variable, a constant value such as
a string or number, a call to a function or method, a sum with “+”, or
just about anything else you could write in an ordinary expression
outside of the string. At the end of the expression, write
<code class="language-plaintext highlighter-rouge">\&gt;\&gt;</code> - two greater-than signs, the mirror
image of the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> that started the embedding.
That returns you to string mode, so you’re back to writing static
literal text in the string.</p>

<p>When a double-quoted string is displayed, TADS first displays the part
of the string up to the first <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code>, then it
evaluates the expression inside that first <code class="language-plaintext highlighter-rouge">\&lt;\&lt;
\&gt;\&gt;</code> section. This expression could be another double-quoted
string, or a call to a method that prints something out. Or, it could be
a call to a function that returns a string value, or a number, or some
other value. If the expression returns a value, TADS prints out this
value, assuming it has a printable form. Strings and numbers are printed
in the obvious way. Most other objects don’t have any kind of automatic
printed form, though; embeddings should only use values that are
printable. Next, TADS prints the next part of the string - the part up
to the <em>next</em> <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> embedding, or to the end of
the string if this was the last one. This process repeats until the
whole string and all of its embeddings have been printed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local i = 3, j = 'boo';
    "The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!&lt;br&gt;";
       // prints out: The value of i is 3, and j is boo!
</code></pre></div></div>

<p>Going back to our door example, we can use an embedding to rewrite it
like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "It's a sturdy-looking oak door, ten feet high. A weathered
    wrought iron knocker is centered just above your eye level.
    The door &lt;&lt;door.isOpen ? "stands open" : "is firmly shut"&gt;&gt;.";
</code></pre></div></div>

<p>Rather than ending the string at the point where we need the varying
message about the door’s status, we use <code class="language-plaintext highlighter-rouge">\&lt;\&lt;
\&gt;\&gt;</code> to embed an expression that prints the variable part. The
expression uses the <code class="language-plaintext highlighter-rouge">? :</code> conditional operator
to test the current status, displaying one string if the door is open
and another if it’s closed. At the end of the expression we go back into
the string text, where we add the closing period and end the message.</p>

<p>This is obviously a lot less typing than the original way we wrote it,
and it’s a bit easier to read, too. It also lets you use the simpler
property-value syntax if the string is used as an object property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "It's a sturdy-looking oak door, ten feet high. A weathered
           wrought iron knocker is centered just above your eye level.
           The door &lt;&lt;isOpen ? "stands open" : "is firmly shut"&gt;&gt;.";
</code></pre></div></div>

<h3 id="nested-embeddings">Nested embeddings</h3>

<p>Starting in version 3.1.3, it’s legal to put one embedding inside
another. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "The refrigerator door is &lt;&lt;
      isOpen ? "open&lt;&lt;isLit ? " and the light inside is on" : ""&gt;&gt; : "closed"&gt;&gt;. ";
</code></pre></div></div>

<p>The most common situation where nesting comes in handy is with
conditional expressions, such as in our example above. Note that you can
often accomplish the same thing with more readable code using the
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> notation, described later in this
chapter. For our example above, we could instead write this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "The refrigerator door is &lt;&lt;if isOpen&gt;&gt;open&lt;&lt;if isLit&gt;&gt; and the
    light inside is on&lt;&lt;end&gt;&gt;&lt;&lt;else&gt;&gt;closed&lt;&lt;end&gt;&gt;. ";
</code></pre></div></div>

<p>There’s a limit on the nesting depth (currently 10 levels). The compiler
will display an error if you exceed the maximum depth.</p>

<h3 id="embeddings-in-single-quoted-strings"><span id="embedSgl"></span>Embeddings in single-quoted strings</h3>

<p>Starting in TADS 3.1, single-quoted strings can also contain embeddings.
The syntax is exactly the same as for double-quoted strings: an
embedding starts with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> and ends with
<code class="language-plaintext highlighter-rouge">\&gt;\&gt;</code>, and between the two brackets you write
an ordinary expression.</p>

<p>When a single-quoted string is evaluated, the process is almost the same
as for double-quoted strings. Rather than printing anything, though,
TADS concatenates the pieces together to create a string result value.
The new string starts with the part of the source string up to the first
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code>. Then TADS evaluates the first
<code class="language-plaintext highlighter-rouge">\&lt;\&lt; \&gt;\&gt;</code> expression, and concatenates the
value to the result string. TADS then concatenates the next source
string segment to the result. This process repeats as before. At the end
of it we have a string value that combines all of the static bits with
all of the embedded expression values, in the order in which they appear
in the source code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local i = 3, j = 'boo';
    local s = 'The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!';
       // s now contains 'The value of i is 3, and j is boo!'
</code></pre></div></div>

<p>A single-quoted string is assembled into a final value <em>at the moment of
evaluation</em>. It won’t change to reflect changes in the underlying
variables. Let’s continue our example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "s is: &lt;&lt;s&gt;&gt;\n";
    i = 7;
    j = 'boo hoo';
    "s is now: &lt;&lt;s&gt;&gt;\n";
</code></pre></div></div>

<p>This prints out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    s is: The value of i is 3, and j is boo!
    s is now: The value of i is 3, and j is boo!
</code></pre></div></div>

<p>Even though we changed <code class="language-plaintext highlighter-rouge">i</code> and
<code class="language-plaintext highlighter-rouge">j</code> after setting <code class="language-plaintext highlighter-rouge">s</code>,
<code class="language-plaintext highlighter-rouge">s</code> doesn’t change - it just stores the
character string assembled in the original assignment. Usually, this is
just what you want. But if for some reason you want a “live” string that
automatically updates every time you use it, you can use an anonymous
function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local i = 3, j = 'boo';
    local s = {: 'The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!'};
    "s is: &lt;&lt;s()&gt;&gt;\n";

    i = 7;
    j = 'boo hoo';
    "s is now: &lt;&lt;s()&gt;&gt;\n";
</code></pre></div></div>

<p>This prints:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    s is: The value of i is 3, and j is boo!
    s is now: The value of i is 7, and j is boo hoo!
</code></pre></div></div>

<p>Note that you’ll usually want to avoid calling routines that print out
messages from within single-quoted string embeddings. Messages that are
printed out aren’t returned as values, so they won’t be concatenated
into the string result - they’ll just appear on the screen <em>at the time
the string is evaluated</em>, which will probably be out of context.</p>

<p>sprintf-style formatting</p>

<p>Starting in 3.1.1, you can specify a <a href="tadsgen.html#sprintf">sprintf()</a>
formatting code directly in an embedded expression, to customize how the
value is displayed. To do this, place the <code class="language-plaintext highlighter-rouge">%</code>
code immediately after the opening <code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code>,
without any intervening spaces. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = 100;
    "x in octal is &lt;&lt;%o x&gt;&gt;\n";
</code></pre></div></div>

<p>The compiler internally turns this into a call to sprintf() with the
given format code, as though you had written:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "x in octal is &lt;&lt;sprintf('%o', x)&gt;&gt;\n";
</code></pre></div></div>

<p>Since it’s really just a call to sprintf(), you can use any format code
that sprintf() accepts.</p>

<p>Custom embedding syntax with string templates</p>

<p>The basic embedded expression syntax is powerful, since it lets you
write any TADS expression. The drawback is that it makes a sort of
Frankenstein’s monster out of a string, switching back and forth between
English text and programming code. The code syntax tends to interrupt
the flow of the English text, making it harder to see how the final
output will look.</p>

<p>The “string template” syntax can help with this. A string template is a
custom phrase that you define for use in string embeddings. The compiler
converts the phrase into a function call. This lets you get the effect
of a function call without having to write the technical looking
function call syntax.</p>

<p>For example, suppose we want to print out the current score, but in
words rather than as digits - “twenty points” rather than “20 points”.
The general-purpose way of doing this is to make a call to a
number-speller function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Your current score is &lt;&lt;spellInt(score)&gt;&gt; points.";
</code></pre></div></div>

<p>To make this read a little better, we could define a template for the
spellInt() function. Rather than explicitly calling the function, we
write an English-like phrase. Here’s how we define the template:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    string template &lt;&lt;* in words&gt;&gt; spellInt;
</code></pre></div></div>

<p>The definition starts with the keywords <code class="language-plaintext highlighter-rouge">string
template</code>. Next comes the list of keywords for the template,
enclosed in the same <code class="language-plaintext highlighter-rouge">\&lt;\&lt; \&gt;\&gt;</code> brackets used
for an embedding. Finally, you give the name of the function to call
when the template is invoked.</p>

<p>The {*} in the template means “the expression part goes here”. This can
come at the beginning (as in this example), at the end, or in the middle
of the phrase - whatever works best for the wording you’re using. When
the compiler matches the template in an embedding, it takes the part
that matched the <code class="language-plaintext highlighter-rouge">\*</code> and treats them as another
embedding:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Your current score is &lt;&lt;score in words&gt;&gt; points.";
</code></pre></div></div>

<p>The compiler matches this to our <code class="language-plaintext highlighter-rouge">\&lt;\&lt;\* in
words\&gt;\&gt;</code> template. The part that matches the
<code class="language-plaintext highlighter-rouge">\*</code> is <code class="language-plaintext highlighter-rouge">score</code>, so the
compiler turns this into a function call to
<code class="language-plaintext highlighter-rouge">spellInt(score)</code>. You could just as well write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "Doubling your score would give you &lt;&lt;score*2 in words&gt;&gt; points.";
</code></pre></div></div>

<p>This time the <code class="language-plaintext highlighter-rouge">\*</code> matches
<code class="language-plaintext highlighter-rouge">score\*2</code>, so the compiler turns this into a
call to <code class="language-plaintext highlighter-rouge">spellInt(score\*2)</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">\*</code> in a template is optional. If you write
a template without a <code class="language-plaintext highlighter-rouge">\*</code>, it will only match an
embedding that’s exactly the phrase given in the template (with no added
words), and the compiler calls its associated function with no
arguments. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    string template &lt;&lt;player location&gt;&gt; playerLoc;
    playerLoc() { return gPlayerChar.location.name; }
</code></pre></div></div>

<p>Now we can write</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "You are in &lt;&lt;player location&gt;&gt;."
</code></pre></div></div>

<p>It’s possible to create ambiguous templates, where two or more templates
could match the same input. If there’s any ambiguity, the compiler goes
in the order of definition: the first template defined wins.</p>

<p>Template invocations can be nested. After the compiler matches one
template, it goes back over the tokens that matched the
<code class="language-plaintext highlighter-rouge">\*</code> and checks them for another template match.
If it finds one, it checks again for a third template match, and so on.
There’s one exception: if the entire template matched is
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;\*\&gt;\&gt;</code>, the compiler doesn’t check for
another template, since this would just keep matching that same
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;\*\&gt;\&gt;</code> template over and over.</p>

<p>Here’s an example of how we could use nested templates:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    string template &lt;&lt;* in words&gt;&gt; spellInt;
    string template &lt;&lt;twice *&gt;&gt; times2;

    "x doubled is &lt;&lt;twice x in words&gt;&gt;.";
</code></pre></div></div>

<p>The order of the templates in a situation like this is important. Since
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;\* in words\&gt;\&gt;</code> is defined first, it
matches first, so the compiler turns this into a call to
<code class="language-plaintext highlighter-rouge">spellInt(twice x)</code>. But before doing that, the
compiler checks what’s left over - <code class="language-plaintext highlighter-rouge">twice x</code> -
to see if it matches another template. It does, so the compiler turns
that into <code class="language-plaintext highlighter-rouge">times2(x)</code>. The overall result is
then <code class="language-plaintext highlighter-rouge">spellInt(times2(x))</code>.</p>

<p>A <code class="language-plaintext highlighter-rouge">string template</code> statement has to be at the
“top level” of your program, outside of any function or object
definitions. String template definitions are <strong>local to a single source
module</strong>, so the best way to make them available throughout your program
is to put them all in a central “.h” header file that you #include in
each source file.</p>

<h3 id="embedded-conditions-with-if"><span id="embeddedIf">Embedded conditions with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code></span></h3>

<p>We’ve seen how we can embed conditional tests in strings using the
<code class="language-plaintext highlighter-rouge">?:</code> operator. That’s a very flexible approach,
but the syntax can be a little awkward. Using it to place multiple
strings in an embedding makes for a lot of quote marks, and interrupts
the reading flow of the text.</p>

<p>The embedded expression syntax has a special if-then-else feature that
can make code more readable. Here’s a another way to write the
open/closed door example we saw earlier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "It's a sturdy-looking oak door, ten feet high. A weathered
           wrought iron knocker is centered just above your eye level.
           The door &lt;&lt;if isOpen&gt;&gt;stands open&lt;&lt;else&gt;&gt;is firmly shut&lt;&lt;end&gt;&gt;. ";
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> evaluates the expression you give
it as a condition. If the condition is true, it continues on to the text
immediately following the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code>. If the
condition is false, the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> skips that
text, and instead looks for a matching
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code>. If it finds one, it continues
from there. Otherwise it keeps going until it finds the matching
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code> label, and proceeds from there.</p>

<p>You can leave out the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code>, in which
case the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> simply skips ahead to the
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code> if the condition is false. In
fact, you can even leave out the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code>,
in which case the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> automatically
ends at the end of the overall string. This lets you write nice concise
code for simple cases like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "It's an old rag. &lt;&lt;if isDamp&gt;&gt;It seems a bit damp. "
</code></pre></div></div>

<p>You can write an <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> with multiple
branches, using the sequence <code class="language-plaintext highlighter-rouge">\&lt;\&lt;else if\&gt;\&gt;</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "The ball is made of &lt;&lt;if color == 1&gt;&gt;bright red&lt;&lt;
           else if color == 2&gt;&gt;green&lt;&lt;else if color == 3&gt;&gt;navy blue&lt;&lt;end&gt;&gt;
           plastic. "
</code></pre></div></div>

<p>The entire series of
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code>…<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else
if\&gt;\&gt;</code>…<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else
if\&gt;\&gt;</code>…<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code> branches counts
as a single “if”, so only one <code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code> is
needed for the whole thing. By the same token, only one plain
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code> is allowed for the whole
sequence, and it must be the last branch. At run time, exactly one of
the branches will be taken, since the branches are all mutually
exclusive.</p>

<p>You can also nest an <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> within another
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> for more complex conditions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "The refrigerator door is &lt;&lt;if isOpen&gt;&gt;open&lt;&lt;if isLit&gt;&gt; and the
           light inside is on&lt;&lt;end&gt;&gt;&lt;&lt;else&gt;&gt;closed&lt;&lt;end&gt;&gt;. "
</code></pre></div></div>

<p>Nesting works in the obvious way, with each
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code> and
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code> pairing up with an
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> from the “inside out” in the
nesting order. So in the string above, the first
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;end\&gt;\&gt;</code> pairs up with
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if isLit\&gt;\&gt;</code> - which makes the
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code> go with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if
isOpen\&gt;\&gt;</code>, since <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if isLit\&gt;\&gt;</code> is
finished at that point. If we run the string with the different
combinations of <code class="language-plaintext highlighter-rouge">isOpen</code> and
<code class="language-plaintext highlighter-rouge">isLit</code>, here’s what we’ll get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    isOpen=nil, isLit=nil:   The refrigerator door is closed.
    isOpen=nil, isLit=true:  The refrigerator door is closed.
    isOpen=true, isLit=nil:  The refrigerator door is open.
    isOpen=true, isLit=true: The refrigerator door is open and the light inside is on.
</code></pre></div></div>

<p>You can nest <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code>’s to any depth -
you’re not limited to just putting one
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> inside another. Of course, whether
the result remains readable is another matter.</p>

<p>Speaking of readability, there are two extra keywords you can use with
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> structures. First, you can use
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;unless\&gt;\&gt;</code> in place of
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> to test that a condition <em>isn’t</em>
true. <code class="language-plaintext highlighter-rouge">\&lt;\&lt;unless x\&gt;\&gt;</code> means exactly the same
thing as <code class="language-plaintext highlighter-rouge">\&lt;\&lt;if !x\&gt;\&gt;</code>, but most people find
it a little less taxing on the brain to rephrase a negative like this,
and in any case it cuts down on punctuation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "An old sepia photo of a group of dour, serious men in suits.
            &lt;&lt;unless moved&gt;&gt;It hangs on the wall at a crooked angle. "
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">\&lt;\&lt;else\&gt;\&gt;</code> with
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;unless\&gt;\&gt;</code> as well:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "An imposing metal box five feet on a side, painted a drab green.
            &lt;&lt;unless isOn&gt;&gt;It sits inertly in the center of the chamber.
            &lt;&lt;else&gt;&gt;It hums and vibrates with an internal energy that seems
               only barely contained. "
</code></pre></div></div>

<p>The second variation is that you can substitute the word “otherwise” for
“else”. These are pure synonyms; both are allowed simply to let you use
the wording you find more intuitive. Note that
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;otherwise unless\&gt;\&gt;</code> is valid as well - it
simply means the same thing as <code class="language-plaintext highlighter-rouge">\&lt;\&lt;else if
!...\&gt;\&gt;</code>.</p>

<h3 id="random-and-other-selections-with-one-of"><span id="oneof"></span>Random (and other) selections with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code></h3>

<p>Another special syntax makes it easy to create messages with
alternatives that are chosen randomly or sequentially. This is handy for
reducing repetition in messages that are displayed repeatedly, such as
atmospheric messages or random NPC behavior.</p>

<p>The basic structure of a message with random alternatives looks like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "The sphere is currently glowing a ghostly &lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;green&lt;&lt;or&gt;&gt;blue&lt;&lt;at random&gt;&gt;. ";
</code></pre></div></div>

<p>The list of alternatives starts with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one
of\&gt;\&gt;</code>. After this you simply write the alternatives, separated
by <code class="language-plaintext highlighter-rouge">\&lt;\&lt;or\&gt;\&gt;</code>. At the end of the list, you
write one of the following, which not only ends the list but also
specifies how to pick an alternative each time the message is displayed:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;cycling\&gt;\&gt;</code> - run through the
alternatives in the order listed, and after showing them all, start
over again at the first item.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;stopping\&gt;\&gt;</code> - run through the
alternatives in order, and after showing them all, just keep showing
the last item from then on.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;purely at random\&gt;\&gt;</code> - choose an
alternative at random each time the message is displayed. Each item
has the same probability, so if there are three alternatives, each one
will be chosen about a third of the time. “Purely” at random means
that each pick is completely independent of the previous picks, the
same as rolling dice or flipping a coin.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;then purely at random\&gt;\&gt;</code> - run through
the items in order once, and after showing them all, behave like
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;purely at random\&gt;\&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;at random\&gt;\&gt;</code> - same as
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;purely at random\&gt;\&gt;</code>, except that the
same item won’t be chosen twice in a row, to reduce the appearance of
obvious repetition. Don’t use this when there are only two options,
since this forces an alternating sequence, A B A B A B…</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;then at random\&gt;\&gt;</code> - run through the
items in order once, and after showing them all, behave like
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;at random\&gt;\&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;as decreasingly likely outcomes\&gt;\&gt;</code> -
this is similar to <code class="language-plaintext highlighter-rouge">\&lt;\&lt;purely at random\&gt;\&gt;</code>,
but with skewed probabilities. The items are assigned relative
probabilities starting at 1 for the last item, 2 for the second to
last, 3 for the third to last, and so on. This makes the first item
<em>N</em> times as likely as the last in an <em>N</em>-item list.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;shuffled\&gt;\&gt;</code> - shuffle the items into a
random order, like a deck of cards, and run through the whole list in
that order. After showing all of the items, shuffle them again and
start over. This reduces repetition by going through the whole list
before repeating an item.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;then shuffled\&gt;\&gt;</code> - run through the
items once in the order written, and after showing them all, act like
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;shuffled\&gt;\&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;half shuffled\&gt;\&gt;</code> - similar to
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;shuffled\&gt;\&gt;</code>, but only shows half the
items before re-shuffling. Oddly, the very lack of repetition in
shuffled mode is sometimes discernible as a pattern in its own right.
This approach can help reduce that effect.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;then half shuffled\&gt;</code> - run through the
items once in the order written, and after showing them all, act like
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;half shuffled\&gt;\&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">\&lt;\&lt;sticky random\&gt;\&gt;</code> - pick an item at
random the first time the message is displayed, then show that same
item every time. This is useful for “replay” variation, since it lets
you set up a detail that varies each time the game is played, but
which remains consistent within a single run-through.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code> structures can be nested, and
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;if\&gt;\&gt;</code> and <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one
of\&gt;\&gt;</code> can be nested within one another.</p>

<p>For each <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code> structure, the
compiler creates an unnamed object of class OneOfIndexGen, as the “index
generator” for the list. This class is defined in the system library
file _main.t, which is normally included automatically in the build.
(“Normally” means as long as you don’t use the compiler’s
<code class="language-plaintext highlighter-rouge">-nodef</code> option to exclude _main.t.)</p>

<p>One-time only messages with <code class="language-plaintext highlighter-rouge">\&lt;\&lt;first time\&gt;\&gt;</code></p>

<p>Some passages are only meant to be seen once, the first time they’re
encountered. The <code class="language-plaintext highlighter-rouge">\&lt;\&lt;first time\&gt;\&gt;</code> syntax
makes this easy:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    desc = "Tightly packed sandstone blocks line the walls of this
       musty chamber.  The floor is cracked and tilts at odd angles,
       and the ceiling sags so low in places you have to crouch.
       &lt;&lt;first time&gt;&gt;You realize you're probably the first person
       to set foot here in at least a thousand years.&lt;&lt;only&gt;&gt;"
</code></pre></div></div>

<p>The text between <code class="language-plaintext highlighter-rouge">\&lt;\&lt;first time\&gt;\&gt;</code> and the
matching <code class="language-plaintext highlighter-rouge">\&lt;\&lt;only\&gt;\&gt;</code> will only be displayed
the first time the overall string is displayed. After that it’ll
disappear from the enclosing text.</p>

<p>Alert readers will notice that <code class="language-plaintext highlighter-rouge">\&lt;\&lt;first
time\&gt;\&gt;</code>…<code class="language-plaintext highlighter-rouge">\&lt;\&lt;only\&gt;\&gt;</code> is the same as
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code><em>first time
text</em><code class="language-plaintext highlighter-rouge">\&lt;\&lt;or\&gt;\&gt;</code><code class="language-plaintext highlighter-rouge">\&lt;\&lt;stopping\&gt;\&gt;</code>.
In fact, the compiler processes <code class="language-plaintext highlighter-rouge">\&lt;\&lt;first
time\&gt;\&gt;</code> by rewriting it exactly as such. So the extra syntax
isn’t really needed, but this is such a common motif in IF authoring
that it’s nice to have a more concise way of writing it.</p>

<h3 id="more-on-evaluation-timing-and-a-warning-on-side-effects">More on evaluation timing, and a warning on side effects</h3>

<p>It’s important to keep in mind that a string with an embedded expression
is “live”. The embedded expression is re-evaluated every time the string
itself is evaluated, and the new, current value is used in the result.</p>

<p>Let’s look more closely at how this evaluation timing works. When you
write a string as part of a function, it’s fairly simple to see when it
gets evaluated: it’s evaluated when that particular line of code is
executed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    test(x)
    {
       local s = 'The current value of x is &lt;&lt;x&gt;&gt;.';
       s = s + '\n';
       return s;
    }
</code></pre></div></div>

<p>Here, the embedding is evaluated just once each time through the test()
function. Once we evaluate the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;x\&gt;\&gt;</code>
expression, we have our final string. The next line where we append a
newline to the string doesn’t re-evaluate the expression, since we
already have our final string. Likewise, when we
<code class="language-plaintext highlighter-rouge">return s</code>, we return that final string value we
already computed, so we don’t evaluate the expression again.</p>

<p>It’s a little more subtle when we put the string into a property value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    orb: Thing 'orb' 'orb'
        desc = "The orb is glowing a bright &lt;&lt;color&gt;&gt;. "
        color = '&lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;blue&lt;&lt;or&gt;&gt;green&lt;&lt;cycling&gt;&gt;'
    ;
</code></pre></div></div>

<p>It might appear at first glance that we’re assigning a final value of
the string to <code class="language-plaintext highlighter-rouge">color</code>, just as we did in the
function. But that’s not what happens; the
<code class="language-plaintext highlighter-rouge">color</code> property in this case is actually a
method. The compiler treats it exactly as though you’d written this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    color()
    {
       return '&lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;blue&lt;&lt;or&gt;&gt;green&lt;&lt;cycling&gt;&gt;';
    }
</code></pre></div></div>

<p>This means that each time you evaluate
<code class="language-plaintext highlighter-rouge">orb.color</code>, you’ll get a new result, since the
“one of” selection occurs dynamically on each evaluation. So each time
we EXAMINE ORB, it will change color.</p>

<p>This internal conversion to a method always happens when you use
embedded expressions. In fact, it happens when you use any sort of
dynamic expression in a method definition. The same thing happens if you
write something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    orb: Thing
       weight = (rand(5))
    ;
</code></pre></div></div>

<p>Any time a property definition contains a dynamic expression value, the
compiler automatically turns the property into a method that evaluates
the expression and returns the result. Strings with embedded expressions
are just a special way of writing a dynamic expression, so they get the
same treatment.</p>

<p>You should be especially careful with embedded expressions that have
side effects. A “side effect” expression is one that makes some global
change in the program, such as <code class="language-plaintext highlighter-rouge">++</code> or
<code class="language-plaintext highlighter-rouge">--</code> expressions, assignments, or calls to
functions that print text. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    blob: Thing 'blob' 'blob'
       desc = "It just keeps growing; it's now up to &lt;&lt;++size&gt;&gt; feet across! "
       size = 0
    ;
</code></pre></div></div>

<p>Every time we evaluate <code class="language-plaintext highlighter-rouge">desc</code>, the size will go
up by a foot. That means that EXAMINE BLOB will cause it to grow.</p>

<p>Things get even more complicated when we combine properties, lists, and
string embeddings. Consider this example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    atmosphereList: object
       eventList = [
          'To err is human; to really screw things up you need
          &lt;&lt;one of&gt;&gt;a computer&lt;&lt;or&gt;&gt;a committee of experts&lt;&lt;or&gt;&gt;an
          Act of Parliament&lt;&lt;or&gt;&gt;Vulcan logic&lt;&lt;or&gt;&gt;a roomful of
          lawyers&lt;&lt;cycling&gt;&gt;. ' ,

          'This message has displayed &lt;&lt;if ++count == 1&gt;&gt;once&lt;&lt;
          else if count == 2&gt;&gt;twice&lt;&lt;else&gt;&gt;&lt;&lt;count&gt;&gt; times&lt;&lt;end&gt;&gt;. '
       ]
            
       count = 0

       getNext()
       {
           if (curIndex &gt; eventList.length())
               curIndex = 1;

           return eventList[curIndex++];
       }
       curIndex = 1
    ;
</code></pre></div></div>

<p>Here’s what’s displayed if we repeatedly print out the result of calling
<code class="language-plaintext highlighter-rouge">atmosphereList.getNext()</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    To err is human; to really screw things up you need a committee of experts.

    This message has displayed 4 times.

    To err is human; to really screw things up you need a computer.

    This message has displayed 8 times.

    To err is human; to really screw things up you need a roomful of lawyers.

    This message has displayed 12 times.
</code></pre></div></div>

<p>If you look carefully at the <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code>
list, you’ll see that the order of the messages is different from what’s
in the list: for example, rather than seeing “a computer” in the first
message, we see “a committee of experts”, which is the second list
entry. Even more obvious is the counter displayed every other time: it
jumps by increments of 4, rather than one at a time, as the
<code class="language-plaintext highlighter-rouge">++count</code> would seem to suggest.</p>

<p>What’s going on? To understand this, you have to remember the general
rule for a property containing an expression: the compiler turns it into
a method that evaluates the expression and returns the result. Now, a
list that contains expressions in its element values is just like a
string that contains embedded expressions: the compiler treats the list
as an expression that consists of assembling a list dynamically out of
the component expressions. If we deconstruct what the compiler does with
the <code class="language-plaintext highlighter-rouge">eventList</code> property, we get something like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    eventList()
    {
       return new List(
          'To err is human; to really screw things up you need '
          + oneOfHandler('a computer', 'a committee of experts',
                         'an Act of Parliament', 'Vulcan logic',
                         'a roomful of lawyers')
          + '.',

          'This message has been displayed '
          + (++count == 1 ? 'once' : count == 2 ? 'twice' : (count + 'times'))
          + '. '
       );
    }
</code></pre></div></div>

<p>That’s pseudo-code, of course, not the actual code the compiler
generates internally; but it should give you a clearer picture of what’s
going on. Each time we evaluate
<code class="language-plaintext highlighter-rouge">atmosphereList.eventList</code>, we have to build
that entire list anew, and that means that we have to build each of the
strings anew, which triggers the various side effects: cycling through
the “one of” list, and incrementing the <code class="language-plaintext highlighter-rouge">count</code>
property. This means that <em>each</em> of the following will trigger <em>all</em> of
the side effects:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    atmosphereList.eventList
    atmosphereList.eventList[1]
    atmosphereList.eventList.length()
    atmosphereList.eventList[++curIndex]
</code></pre></div></div>

<p>The thing that’s surprising is that an expression like
<code class="language-plaintext highlighter-rouge">atmosphereList.eventList\[1\]</code> would trigger
the side effects not only in element <code class="language-plaintext highlighter-rouge">\[1\]</code>,
but in element <code class="language-plaintext highlighter-rouge">\[2\]</code> as well. But that is
indeed what happens: before TADS can even start thinking about
retrieving element <code class="language-plaintext highlighter-rouge">\[1\]</code>, it has to construct
the whole list dynamically, which means it evaluates all of the
individual element expressions, not just the expression for element
<code class="language-plaintext highlighter-rouge">\[1\]</code>.</p>

<p>You’ll notice that the <code class="language-plaintext highlighter-rouge">getNext()</code> method
evaluates the <code class="language-plaintext highlighter-rouge">eventList</code> property twice - once
to get its length, and again to retrieve the element value. That’s why
we see the second <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code> element on
the first go-round: we’re actually working with the second evaluation of
the list, so we get the second <code class="language-plaintext highlighter-rouge">\&lt;\&lt;one of\&gt;\&gt;</code>
item. That’s also why we see “4 times” on the second message. By then,
that <code class="language-plaintext highlighter-rouge">++count</code> expression has been evaluated
four times: twice for the first <code class="language-plaintext highlighter-rouge">getNext()</code>
call, and twice again for the second.</p>

<h2 id="full-list-of-backslash-codes"><span id="backslash"></span>Full list of backslash codes</h2>

<p>We’ve already seen how the backslash “\ is used to escape quote marks,
<code class="language-plaintext highlighter-rouge">\&lt;</code> signs, and the backslash itself - meaning
that it removes their special meaning and makes them into ordinary
literal text characters.</p>

<p>The backslash has another use, which is that it <em>adds</em> special meanings
to some ordinary characters. It’s sort of a role reversal from what
we’ve seen so far, but it makes a certain kind of sense, if you think
about a quote mark’s regular meaning as “end this string” and its
special backslash meaning as “a literal quote mark.”</p>

<p>Here are all of the special backslash sequences:</p>

<p>\</p>

<p>A (single) literal backslash character</p>

<p>\</p>

<p>A literal <code class="language-plaintext highlighter-rouge">\&lt;</code> character. The only time it’s
necessary to write <code class="language-plaintext highlighter-rouge">\\</code> rather than just
<code class="language-plaintext highlighter-rouge">\&lt;</code> is when you use two (or more)
<code class="language-plaintext highlighter-rouge">\&lt;</code>’s in a row: you must escape the second (and
third, etc) to prevent the compiler from treating
<code class="language-plaintext highlighter-rouge">\&lt;\&lt;</code> as the start of an embedded expression.
Very important: writing <code class="language-plaintext highlighter-rouge">\\</code> does <strong>not</strong>
prevent the display layer from reading the <code class="language-plaintext highlighter-rouge">\&lt;</code>
as the start of an HTML tag. For that, you must write the less-than sign
as “<code class="language-plaintext highlighter-rouge">&amp;lt;</code>”.</p>

<p>\</p>

<p>A literal <code class="language-plaintext highlighter-rouge">\&gt;</code> character. It’s never necessary
to escape <code class="language-plaintext highlighter-rouge">\&gt;</code>, but it’s harmless to do so. This
doesn’t prevent the HTML parser from treating the
<code class="language-plaintext highlighter-rouge">\&gt;</code> as the end of a tag; use
“<code class="language-plaintext highlighter-rouge">&amp;gt;</code>” for that.</p>

<p>\</p>

<p>A literal double-quote character</p>

<p>\</p>

<p>A literal single-quote character</p>

<p>\</p>

<p>Caps mode: capitalize the next character to be displayed, <em>if</em> it’s
alphabetic. (^ is the circumflex, usually shift-6 on a QWERTY keyboard.)</p>

<p>\v</p>

<p>Un-caps mode: convert the next character to be displayed to lower-case,
<em>if</em> it’s alphabetic. (That’s not a special arrow character, just an
ordinary lower-case “v”.)</p>

<p>\</p>

<p>(Backslash-space) Show a quoted space. In plain text interpreters
<strong>only</strong>, this shows an extra space even if a space character is
adjacent. It also prevents the display system from adding an extra space
after a period or other double-spaced punctuation mark.</p>

<p>\b</p>

<p>Show a blank line. This ends the current line and adds an extra blank
line after it.</p>

<p>\n</p>

<p>Newline. This ends the current line and starts a new one. This is
similar to the HTML tag <code class="language-plaintext highlighter-rouge">\&lt;br\&gt;</code>, with the
exception that two or more consecutive <code class="language-plaintext highlighter-rouge">\n</code>
marks are consolidated, so they don’t show any blank lines. The
interpreter groups a run of <code class="language-plaintext highlighter-rouge">\n</code> marks into a
single line break. This is designed to help with a common situation in
IF coding, which is that you often construct output in fragments from
different sections of the program. These different sections don’t always
know what other text will be displayed just before or after their text,
since the adjacent text will likely come from some distant part of the
code. Consolidating line breaks allows one section to show a line break
without having to worry too much about whether the previous of next
section will also show a line break; if there’s another adjacent line
break, the two will be automatically combined, avoiding messy output
with too many blank lines. Of course, this means that you can’t use an
explicit series of \n codes to display blank lines - when you want to do
that, you need to use \b.</p>

<p>\r</p>

<p>Carriage Return, ASCII 13. This character has no formatting significance
to TADS, so there’s no reason to use it when writing output to the
display or to text files. In fact, it’s best to avoid it, because using
it inevitably gets into the details of line endings. That’s a
long-standing mess; each operating system has its own conventions, and
no one is willing to adopt a common standard because it would cause so
much compatibility upheaval. Fortunately, TADS is pretty good at working
around this mess automatically, as long as you stick with
<code class="language-plaintext highlighter-rouge">\n</code> in program code. TADS translates
<code class="language-plaintext highlighter-rouge">\n</code> to and from the local conventions when
reading and writing text files, the display, and most anything else
external. Mixing in <code class="language-plaintext highlighter-rouge">\r</code> characters of your own
could interfere with this. The main reason TADS allows
<code class="language-plaintext highlighter-rouge">\r</code> at all in source code is for the sake of
programmers coming from a C/C++/Java background, where
<code class="language-plaintext highlighter-rouge">\r</code> has the same meaning. It’s also useful for
low-level binary I/O, since CR characters are used in several platforms’
newline conventions (notably DOS/Windows), as well as in most of the
text-oriented Web protocols.</p>

<p>\t</p>

<p>Tab. This advances the horizontal position to the next tab stop. Tab
stops are every 8 characters in plain text interpreters. In graphical
interpreters, tabs usually simulate the text-mode tab layout - but this
is often only an approximation, because proportional fonts are usually
used in GUI systems. Because of these platform differences, it’s best to
avoid tabs in displayed output; HTML formatting gives you better
control. As with <code class="language-plaintext highlighter-rouge">\r</code>, the main legitimate use
of <code class="language-plaintext highlighter-rouge">\t</code> is for low-level binary I/O.</p>

<p>\u<em>hhhh</em></p>

<p>Encodes a Unicode character by entering its hexadecimal value <em>hhhh</em>.
For example, <code class="language-plaintext highlighter-rouge">\u0041</code> produces a capital A.</p>

<p>\<em>ooo</em></p>

<p>Encodes an ASCII character by entering its octal value. For example,
\081 produces a capital A. (This is redundant with
<code class="language-plaintext highlighter-rouge">\u</code>, but it’s more familiar for people with a C
language background.)</p>

<p>\x<em>hh</em></p>

<p>Encodes an ASCII character by entering its two-digit hex value. For
example, <code class="language-plaintext highlighter-rouge">\x41</code> produces a capital A. (This is
redundant with <code class="language-plaintext highlighter-rouge">\u</code>, but it’s included for the
sake of Java programmers.)</p>

<p>You shouldn’t use any \ combinations that aren’t listed above, because
while they don’t have any special meaning now, they might be given a
special meaning in a future version. The compiler doesn’t complain about
unknown \ combinations, and simply leaves the entire sequence
(including the \ intact in the string.</p>

<hr />

<p><em>TADS 3 System Manual</em><br />
<a href="toc.html" class="nav">Table of Contents</a> |
<a href="langsec.html" class="nav">The Language</a> &gt; String Literals<br />
<span class="navnp"><a href="types.html" class="nav"><em>Prev:</em> Fundamental Datatypes</a>
    <a href="enum.html" class="nav"><em>Next:</em> Enumerators</a>    
</span></p>


</main>
<footer id="footer">
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>

<script>
    if(window.location !== window.top.location) {
        let header = document.getElementById('header');
        let footer = document.getElementById('footer');
        header.remove();
        footer.remove();
    }
</script>