<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title>docs-adv3-doc-sysman-vector-html</title>
    <meta property="og:title" content=
    "docs-adv3-doc-sysman-vector-html">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header><div class="header-search">
    <form class="header-search-form" action="/search" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<p><img src="topbar.jpg" data-border="0" /></p>

<p><a href="toc.html" class="nav">Table of Contents</a> |
<a href="builtins.html" class="nav">The Intrinsics</a> &gt; Vector<br />
<span class="navnp"><a href="timezone.html" class="nav"><em>Prev:</em> TimeZone</a>
   
<a href="wlookup.html" class="nav"><em>Next:</em> WeakRefLookupTable</a>
    </span></p>

<h1 id="vector">Vector</h1>

<p>Vector is a subclass of <a href="collect.html">Collection</a> that provides an
ordered collection of elements, like <a href="list.html">List</a>, but provides
“reference semantics,” which means that you can modify the elements of a
Vector directly.</p>

<p>To use the Vector class, you should <code class="language-plaintext highlighter-rouge">\#include
\&lt;systype.h\&gt;</code> or <code class="language-plaintext highlighter-rouge">\#include \&lt;vector.h\&gt;</code>
in your source files.</p>

<h2 id="which-should-i-use-list-or-vector">Which should I use: List or Vector?</h2>

<p>The List and Vector classes are very similar; both of these classes
allow you to manage collections of values as a group. The differences
between the classes are a little subtle, but they’re important.</p>

<p>Lists offer two unique features. First, List is an intrinsic T3 VM
datatype, which makes it the “universal” collection type; some functions
and methods require list values, and won’t accept other collection
types. Second, Lists use “value semantics,” so you never have to worry
about the effects of changing a list value to which other parts of your
program might be retaining references.</p>

<p>Vectors use “reference semantics,” which are sometimes trickier to work
with than a List’s value semantics, but offer advantages in some
situations. Reference semantics also make Vectors more efficient when
you’re performing an iterative process that involves repeated updates to
a collection’s elements: if you use a List for such a process, each
update to an element would create a new list value, whereas changes to a
Vector’s elements simply change the existing Vector object, rather than
creating a new Vector.</p>

<p>In general, you can decide which type of collection to use based on what
you’re going to do with it:</p>

<ul>
  <li>If you’re storing a value that will be used by many parts of your
program, such as in an object property, and the value won’t be changed
frequently, List is a good choice. Because of a list’s value
semantics, the different parts of the code that refer to the same list
won’t have to coordinate their activities if they make local changes
to the list.</li>
  <li>If you’ll be updating the elements of a collection frequently, you
should use a Vector. Using a Vector rather than a List avoids the
overhead of creating a new copy of the collection every time you
update one of its members.</li>
  <li>If you’re dynamically building a collection through an iterative
process that involves repeated changes to the collection (additions of
new elements, removal of elements, or updates to existing element
values), you should use a Vector.</li>
</ul>

<h2 id="creating-a-vector">Creating a Vector</h2>

<p>To create a Vector, you use the <code class="language-plaintext highlighter-rouge">new</code> operator.
The constructor can be called with several different argument formats.</p>

<p>The simplest way to call the constructor is with no arguments. This
creates an empty Vector (one with no elements, and a length() of zero)
and a default “initial allocation size” (we’ll explain what that means
shortly).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local x = new Vector();
</code></pre></div></div>

<p>You can also use a single integer argument to specify an initial
allocation size. This still creates an empty vector - its length() will
be zero - but it allows you to control how much memory is initially
allocated for the Vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // create an empty Vector with an initial allocation of 10 elements
    x = new Vector(10);
</code></pre></div></div>

<p>Next, you can create a Vector and fill it in with a given number of
elements already present, populated with <code class="language-plaintext highlighter-rouge">nil</code>
values. To do this, pass two integer values. The first is the initial
allocation length, as above, and the second is the number of slots to
fill in with <code class="language-plaintext highlighter-rouge">nil</code> values. It’s exactly as
though you called <code class="language-plaintext highlighter-rouge">append(nil)</code> that many times
after creating the Vector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // create a Vector with 10 slots allocated, and with 5 slots initially
    // filled in with nil - so x.length() is 5
    x = new Vector(10, 5);
</code></pre></div></div>

<p>You can also create a Vector as a copy of a List or another Vector. To
do this, pass in the source object as the single argument. This creates
a new Vector object and copies all of the elements from the source
object. The new Vector will have the same length() as the source object,
and an initial allocation equal to the length of the source object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // create a Vector with the same elements as a list
    x = new Vector([1, 2, 3]);
</code></pre></div></div>

<p>Finally, you can create a copy of a List or Vector, and also specify the
initial allocation length. This is useful if you want to leave room in
the initial allocation for adding more elements.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // create a copy of the list, but allocate 10 elements initially
    x = new Vector(10, [1, 2, 3]);
</code></pre></div></div>

<p>Note that if the initial allocation you specify in this kind of call is
smaller than what’s required to copy the source object, the constructor
will obviously have to ignore that value and allocate enough space to
hold the initial values.</p>

<h3 id="the-initial-allocation">The initial allocation</h3>

<p>The constructor gives you the option to set the “initial allocation”
size for the Vector. What is this? Well, let’s first look at what it
isn’t.</p>

<p>First, it’s <em>not</em> the initial number of elements in the Vector; that’s
determined by the other arguments. For example, <code class="language-plaintext highlighter-rouge">new
Vector(100)</code> creates an empty vector, even though you’ve specified
a fairly large initial allocation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = new Vector(100);
    say(x.length());  // displays "0"
</code></pre></div></div>

<p>Second, the initial allocation is <em>not</em> the maximum size that the Vector
can ever attain. No matter what initial allocation size you set, a
Vector can grow to any length. The system will simply keep allocating
more memory as needed when you add more elements.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = new Vector(1);
    x.append(1);
    x.append(2);
    x.append(3);
    say(x.length());  // displays "3"
</code></pre></div></div>

<p>Note that it’s perfectly legal to add three elements to this Vector,
even though it was created with room for only one item. A Vector always
expands as needed.</p>

<p>So if the initial allocation size doesn’t set the initial number of
elements in the vector, and it doesn’t set a maximum size, what good is
it? And does it even matter what the value is? The answer is that
setting affects the memory efficiency of the vector. When you first
create the vector, the system internally allocates the number of slots
you specify in the initial allocation size; these slots are marked as
“not yet in use,” because the vector contains no elements at this point,
but they’re available for future use when you add elements. When you add
elements, the Vector puts them into these reserved slots, which is a
very fast operation. If you add more elements than there are reserved
slots, the Vector must allocate more memory, which takes a little more
time.</p>

<p>If you make the initial allocation size too small, the system will have
to allocate more memory for the Vector, possibly more than once, as you
add new elements. If you make the initial allocation too large, the
vector will take up more memory than it will ever actually need.</p>

<p>Don’t worry about this too much, though. The Vector object manages its
memory automatically, so it’s not a big deal if the initial size is too
high or too low. The additional work of allocating more memory isn’t
huge. The initial size parameter is provided only so that you can
fine-tune your program’s performance in cases where you have a pretty
good idea in advance of how large a vector will be; in cases where you
don’t have any way of knowing, you can just pick a number that seems in
the ballpark for a typical case, or omit it entirely and use the default
size.</p>

<h2 id="vector-operators">Vector operators</h2>

<p>The <code class="language-plaintext highlighter-rouge">+</code> operator adds new elements to the end of
a Vector. If the operand on the right side of the
<code class="language-plaintext highlighter-rouge">+</code> is a list or another Vector, its elements
are individually added to the vector; otherwise, the value on the right
side of the <code class="language-plaintext highlighter-rouge">+</code> is added as a single new
element. Note that this operator always creates a new Vector to store
the result; the original vector’s value is unchanged.</p>

<p>The <code class="language-plaintext highlighter-rouge">-</code> operator removes elements from the
Vector. If the operand on the right side of the
<code class="language-plaintext highlighter-rouge">-</code> is a list or Vector, each element of the
list of Vector is individually removed from the Vector on the left of
the <code class="language-plaintext highlighter-rouge">-</code>. If the operand on the right side of the
<code class="language-plaintext highlighter-rouge">-</code> is not a list or vector, each element of the
vector whose value equals the right operand is deleted from the vector
on the left. Note that the <code class="language-plaintext highlighter-rouge">-</code> operator always
creates a new Vector to store the result.</p>

<p>The indexing operator <code class="language-plaintext highlighter-rouge">\[ \]</code> can be used to get
and set elements of the array using an integer index, just as with a
List. If you assign an element of the vector past the current length of
the vector, the vector is automatically extended to include the
necessary number of elements; new elements between the last existing
element and the element at the requested index are set to nil. If you
try to retrieve a vector element with an index higher than any existing
element, a run-time exception (“index out of range”) is thrown.</p>

<p>A Vector can be used with the <code class="language-plaintext highlighter-rouge">==</code> or
<code class="language-plaintext highlighter-rouge">!=</code> operators to compare a Vector to another
value. A Vector is equal to another Vector or List if the other Vector
or List has the same number of elements, and each element of the Vector
equals the corresponding element of the other Vector or List, using the
same rules as the <code class="language-plaintext highlighter-rouge">==</code> operator to compare the
elements.</p>

<p>Note: Because the <code class="language-plaintext highlighter-rouge">==</code> test is defined
recursively, if a Vector contains a reference to itself, either directly
or indirectly through another Vector, the <code class="language-plaintext highlighter-rouge">==</code>
test can recurse infinitely. The Vector class avoids this infinite
recursion by limiting the depth of recursion in an equality comparison
to 256 levels. If this recursion depth is exceeded, the
<code class="language-plaintext highlighter-rouge">==</code> test throws an exception (“maximum equality
test/hash recursion depth exceeded”). This same exception will result,
for the same reason, if a Vector with a self-reference is used as a key
in a LookupTable. The recursion depth exception can occur even if a
Vector contains no self-references, if it simply contains such a complex
series of references that it exceeds the maximum depth. Note that this
limit does not have anything to do with the number of elements in any
Vector; rather, it pertains to the depth of the references from one
Vector to another. So, if you create Vectors A, B, C, D, …, and set
A[1] = B, B[1] = C, C[1] = D, and so on for more than 256 vectors,
then comparing A to another vector could exceed the maximum depth.</p>

<h3 id="string-conversions">String conversions</h3>

<p>A Vector value can be converted to a string using the
<a href="tadsgen.html#toString">toString()</a> function. A Vector can also be used
in a context where a non-string value is implicitly converted to a
string, such as in the <a href="tadsio.html#tadsSay">tadsSay()</a> function or in a
string concatenation (that is, on the right-hand side of a “+” operator
where the left-hand side is a string).</p>

<p>The string conversion of a Vector consists of the Vector’s elements,
each itself first converted to a string if necessary, concatenated
together, with commas separating elements. For example,
<code class="language-plaintext highlighter-rouge">toString(new Vector(\[1, 2, 3\]))</code> yields the
string <code class="language-plaintext highlighter-rouge">'1,2,3'</code>.</p>

<h2 id="vector-methods">Vector methods</h2>

<p>Vector is a subclass of <a href="collect.html">Collection</a>, so the Collection
methods are available on a Vector object. In addition to the Collection
methods, Vector provides many methods of its own, shown below.</p>

<p><code class="language-plaintext highlighter-rouge">append(*val*)</code></p>

<p>Appends the value <em>val</em> to the end of the vector, increasing the
vector’s length by one. This method has almost the same effect as the
<code class="language-plaintext highlighter-rouge">+</code> operator, except for the treatment if <em>val</em>
is a list: this method simply appends a list value as a single new
element, whereas the <code class="language-plaintext highlighter-rouge">+</code> operator appends each
element of the list value as a separate new element. In addition, unlike
the <code class="language-plaintext highlighter-rouge">+</code> operator, this method modifies the
Vector object, rather than creating a new Vector to store the result.
Returns <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p><code class="language-plaintext highlighter-rouge">appendAll(*val*)</code></p>

<p>This works like <code class="language-plaintext highlighter-rouge">append(*val*)</code>, except that if
<em>val</em> is a List or Vector, each element of <em>val</em> is individually
appended to the target Vector. This method works like the
<code class="language-plaintext highlighter-rouge">+</code> operator, except that this method modifies
the Vector, rather than creating a new Vector to store the result.
Returns <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p><code class="language-plaintext highlighter-rouge">appendUnique(*val*)</code></p>

<p>Appends the elements of the list or Vector <em>val</em> to this vector; the
vector is modified so that it consists only of the unique elements of
the combination. On return, any given value will appear in the vector
will appear only once. Like <code class="language-plaintext highlighter-rouge">append()</code> and
<code class="language-plaintext highlighter-rouge">appendAll()</code>, this modifies the Vector
directly.</p>

<p><code class="language-plaintext highlighter-rouge">applyAll(*func*)</code></p>

<p>For each element of the vector, this method invokes the callback
function <em>func</em>, passing the current element as the single argument,
then replaces the vector element with the return value from the
callback. This method does not create a new Vector; rather, it modifies
the original Vector. This method returns <code class="language-plaintext highlighter-rouge">self</code>
as the result value.</p>

<p>This method is useful for transforming the elements of a vector by
applying a modifier function. For example, if we have a vector of
numbers, we could use this method to multiply each number in the vector
by two:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x.applyAll({x: x*2});
</code></pre></div></div>

<p>This method is also handy for performing complex initializations on a
new Vector. For example, here’s a function that creates a new vector and
initializes it with the first <em>n</em> Fibonacci numbers. Because we’re
simply initializing the new vector, note that the callback function
doesn’t make any reference to the original element value, but it must
still declare a parameter for the argument value so that the arguments
passed from <code class="language-plaintext highlighter-rouge">applyAll()</code> match the declaration.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    createFibonacciVector(n)
    {
      local f0 = 0, f1 = 1;
      return new Vector(n, n).applyAll(function(x)
        { local ret = f0; f0 = f1; f1 += ret; return ret; });
    }
</code></pre></div></div>

<p>Note that we specify the value <em>n</em> twice in the constructor to
explicitly set the initial size of the vector to <em>n</em>
<code class="language-plaintext highlighter-rouge">nil</code> elements. This is important because a
newly-created vector normally doesn’t contain any elements, regardless
of the initial allocation setting; by explicitly using the initial
length argument <em>n</em>, we ensure that <code class="language-plaintext highlighter-rouge">applyAll()</code>
will visit <em>n</em> elements.</p>

<p><code class="language-plaintext highlighter-rouge">copyFrom(*source*, *sourceStart*, *destStart*,
*count*)</code></p>

<p>Copies values from a list or from another list or vector into this
Vector. This function doesn’t create a new Vector, but simply modifies
entries in the <code class="language-plaintext highlighter-rouge">self</code> vector. <em>source</em> is the
source of the values; it must be either a vector or a list.
<em>sourceStart</em> is an index into source, and specifies the first element
of source that is to be copied. <em>destStart</em> is an index into the
<code class="language-plaintext highlighter-rouge">self</code> vector, and specifies the first element
of the vector that is to be modified. <em>count</em> is the number of elements
to modify. The method copies elements from <em>source</em> into the
<code class="language-plaintext highlighter-rouge">self</code> vector, one at a time, until it reaches
the last element of source, or has copied the number of elements
specified by count.</p>

<p>If either starting index is negative, it counts backwards from the last
element of its vector: -1 is the last element, -2 is the second to last,
and so on.</p>

<p>Calling this method is equivalent to writing a code fragment like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 0 ; i &lt; count ; ++i)
      dest[destStart + i] = source[sourceStart + i];
</code></pre></div></div>

<p>If necessary, the method expands the <code class="language-plaintext highlighter-rouge">self</code>
vector to make room for the added elements.</p>

<p>The <code class="language-plaintext highlighter-rouge">copyFrom()</code> method simply returns
<code class="language-plaintext highlighter-rouge">self</code>; this is convenient for expressions like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = new Vector(20).copyFrom(lst, 3, 2, 5);
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">countOf(*val*)</code></p>

<p>Returns the number of elements in the vector whose values equal <em>val</em>.</p>

<p><code class="language-plaintext highlighter-rouge">countWhich(*cond*)</code></p>

<p>Returns the number of elements in the vector for which the callback
function <em>cond</em> returns a non-false value (anything but
<code class="language-plaintext highlighter-rouge">nil</code> or 0). For each element in the Vector, the
method invokes <em>cond</em>, passing the element as the argument to the
callback. If <em>cond</em> returns anything but <code class="language-plaintext highlighter-rouge">nil</code>
or 0, the method counts the element. After invoking <em>cond</em> for each
element, the method returns the number of elements for which <em>cond</em>
returned a non-false value.</p>

<p><code class="language-plaintext highlighter-rouge">fillValue(*value*, *start*?, *count*?)</code></p>

<p>Fills elements of this Vector with <em>value</em>. If only <em>value</em> is
specified, this method simply stores <em>value</em> in every element of the
<code class="language-plaintext highlighter-rouge">self</code> vector. If <em>start</em> is specified, it gives
the starting index; the method fills values starting with <em>start</em>, to
the end of the Vector. If both <em>start</em> and <em>count</em> are specified, count
gives the maximum number of elements to fill.</p>

<p>If <em>start</em> isn’t specified, the default starting index is 1. If <em>start</em>
is negative, it counts from the end of the vector: -1 is the last
element, -2 is the second to last, and so on.</p>

<p>If <em>count</em> isn’t specified, the default count is
<code class="language-plaintext highlighter-rouge">self.length() -</code> <em>start</em> <code class="language-plaintext highlighter-rouge">+
1</code>, or 0 if that yields a negative value. In other words, the
default <em>count</em> is chosen to fill to the end of the existing elements of
the Vector. Note that this is the actual populated length of the Vector,
<em>not</em> the initial allocation size: <code class="language-plaintext highlighter-rouge">new
Vector(10).fillValue('x')</code> yields a vector with zero elements
filled in, not 10, because a Vector created this way is initially
empty - the <code class="language-plaintext highlighter-rouge">10</code> is merely the initial
allocation size hint, not the initial filled length.</p>

<p>This method is equivalent to writing a code fragment like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (local i = 0 ; i &lt; count ; ++i)
      dest[start + i] = value;
</code></pre></div></div>

<p>Calling <code class="language-plaintext highlighter-rouge">fillValue()</code> is easier than writing
this code fragment, though, and considerably faster because it is
implemented as native code.</p>

<p>This method returns <code class="language-plaintext highlighter-rouge">self</code>, which allows for
expressions like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = new Vector(20).fillValue('A', 1, 20);
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">forEach(*func*)</code></p>

<p>Invokes the callback function
<code class="language-plaintext highlighter-rouge">(*func*)(*value*)</code> for each element, in order
from first to last, passing the value of one element as <em>value</em> to the
callback on each invocation. The callback function takes one argument
giving the value of the current element, and returns no value. This
method returns no value. This method is a convenient means of executing
some code for each element of the vector.</p>

<p><code class="language-plaintext highlighter-rouge">forEachAssoc(*func*)</code></p>

<p>Invokes the callback function <code class="language-plaintext highlighter-rouge">(*func*)(*index*,
*value*)</code> for each element, in order from first to last, passing
each element’s index and value to the function <em>func</em>. The callback
function returns no value. This method returns no value. This method is
the same as <code class="language-plaintext highlighter-rouge">forEach()</code>, except that this method
provides the callback with the index as well as the value for each
element it visits.</p>

<p><span id="generate"></span></p>

<p><code class="language-plaintext highlighter-rouge">generate(*func*, *n*)</code></p>

<p>Creates a new Vector containing <em>n</em> elements by invoking the callback
function <em>func</em> once for each element, and using the return value as the
element value. This is a class method that you call on the Vector class
directly, as in <code class="language-plaintext highlighter-rouge">Vector.generate(f, 10)</code>.</p>

<p><em>func</em> is a callback function, which can be a regular function or an
anonymous function. <em>func</em> can take zero or one argument. The
one-argument form is invoked with the index of the current element as
the argument on each call.</p>

<p><code class="language-plaintext highlighter-rouge">generate()</code> is convenient for creating a Vector
of items based on a formula. For example, this creates a Vector of the
first ten positive even integers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local e = Vector.generate({i: i*2}, 10);
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getUnique()</code></p>

<p>Returns a new vector consisting of the unique elements of the original
vector. For each value in the original vector, the value will appear in
the new vector only once. The order of the elements in the new vector is
that of the first appearances of the unique elements of the original
vector. For example, if the original vector’s elements are, in order, 1,
5, 2, 5, 3, 5, 4, 5, this method will return a new vector whose elements
are, in order, 1, 5, 2, 3, 4. Note that the size of the new vector is
just large enough to hold only the unique elements, so the new vector
might be smaller than the original vector.</p>

<p><code class="language-plaintext highlighter-rouge">indexOf(*val*)</code></p>

<p>Finds the first element of the vector whose value equals <em>val</em>, and
returns the index of the element. Returns <code class="language-plaintext highlighter-rouge">nil</code>
if none of the vector’s elements equals <em>val</em>.</p>

<p><code class="language-plaintext highlighter-rouge">indexOfMax(*func*?)</code></p>

<p>If <em>func</em> is omitted, returns the index of the element with the maximum
value, comparing values to one another as though using the
<code class="language-plaintext highlighter-rouge">\&gt;</code> operator.</p>

<p>If <em>func</em> is specified, it must be a function pointer. The method calls
<em>func</em>() for each element in the vector, passing the element’s value as
the function argument. The function must return a value. The result of
<code class="language-plaintext highlighter-rouge">indexOfMax</code> in this case is the index of the
element for which <em>func</em>() returned the maximum value.</p>

<p>For example, if <code class="language-plaintext highlighter-rouge">v</code> is a vector containing
string values as elements, <code class="language-plaintext highlighter-rouge">v.indexOfMax({x:
x.length()})</code> returns the index of the longest string.</p>

<p><code class="language-plaintext highlighter-rouge">indexOfMin(*func*?)</code></p>

<p>If <em>func</em> is omitted, returns the index of the element with the minimum
value, comparing values to one another as though using the
<code class="language-plaintext highlighter-rouge">\&lt;</code> operator.</p>

<p>If <em>func</em> is specified, it must be a function pointer. The method calls
<em>func</em>() for each element in the vector, passing the element’s value as
the function argument. The function must return a value. The result of
<code class="language-plaintext highlighter-rouge">indexOfMin</code> in this case is the index of the
element for which <em>func</em>() returned the minimum value.</p>

<p>For example, if <code class="language-plaintext highlighter-rouge">lst</code> is a vector containing
string values as elements, <code class="language-plaintext highlighter-rouge">v.indexOfMin({x:
x.length()})</code> returns the index of the shortest string.</p>

<p><code class="language-plaintext highlighter-rouge">indexWhich(*cond*)</code></p>

<p>Finds the first element for which the given condition is true. The
method iterates through the elements of the vector, starting at the
first element and proceeding in order, and applies the callback function
<em>cond</em> to each element. The callback takes one argument, which is the
value of the vector element, and returns a condition result value. For
each element, if the callback function returns a non-false value (i.e.,
any value except <code class="language-plaintext highlighter-rouge">nil</code> or zero), the method
immediately stops the iteration and returns the index of that element.
If the callback returns a false value (<code class="language-plaintext highlighter-rouge">nil</code> or
zero) for every element of the vector, the method returns
<code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p><code class="language-plaintext highlighter-rouge">insertAt(*startingIndex*, *val*, ...)</code></p>

<p>Inserts one or more values into the vector at the giving starting index.
The size of the vector is increased to accommodate the new elements.
Note that, if any of the values are lists or other collections, they are
simply inserted as single elements; this contrasts with the
<code class="language-plaintext highlighter-rouge">+</code> operator, which adds each element of a list
as a separate element of the vector.</p>

<p>If <em>startingIndex</em> is negative, it counts from the end of the vector: -1
is the last element, -2 is the second to last, etc. The special value 0
means to insert after the last element. If <em>startingIndex</em> is positive,
it must be in the range from 1 to one higher than the length of the
vector. If the starting index value is 1, the new elements are inserted
before the first existing element of the vector. If the starting index
is one higher than the length of the vector, the new elements are
appended after the last existing element of the vector. If the starting
index is out of this valid range, the method throws an error (“index out
of range”).</p>

<p>Returns the <code class="language-plaintext highlighter-rouge">self</code> object.</p>

<p><span id="join"></span></p>

<p><code class="language-plaintext highlighter-rouge">join(*sep*?)</code></p>

<p>Returns a string made by concatenating the elements of the vector
together in index order. If <em>sep</em> is provided, it’s a string that’s
interposed between elements as a separator. If <em>sep</em> is omitted, the
elements are concatenated with no separation.</p>

<p>Each element is converted to a string using the usual automatic
conversions before it’s concatenated. If an element can’t be converted
to string, the method throws an error.</p>

<p><code class="language-plaintext highlighter-rouge">lastIndexOf(*val*)</code></p>

<p>Returns the index of the last element in the vector whose value equals
<em>val</em>. If none of the elements in the vector matches the given value,
the method returns <code class="language-plaintext highlighter-rouge">nil</code>.</p>

<p><code class="language-plaintext highlighter-rouge">lastIndexWhich(*cond*)</code></p>

<p>Finds the last element for which the given condition is true. This
method is similar to <code class="language-plaintext highlighter-rouge">indexWhich(*cond*)</code>, but
scans the vector in reverse order, starting with the last element and
working backwards. Returns the index of the matching element, or
<code class="language-plaintext highlighter-rouge">nil</code> if the condition returns false for every
element.</p>

<p><code class="language-plaintext highlighter-rouge">lastValWhich(*cond*)</code></p>

<p>Finds the last element for which the given condition is true, and
returns the element’s value. This method is similar to
<code class="language-plaintext highlighter-rouge">lastIndexWhich(*cond*)</code>, but returns the value
of the matching element rather than its index. Returns
<code class="language-plaintext highlighter-rouge">nil</code> if no matching element is found.</p>

<p><code class="language-plaintext highlighter-rouge">length()</code></p>

<p>Returns an integer giving the number of elements in the vector. This is
the number of elements actually stored in the vector, and is unrelated
to the initial allocation size specified when the vector was created.</p>

<p><code class="language-plaintext highlighter-rouge">mapAll(*func*)</code></p>

<p>Creates a new vector consisting of the results of applying the callback
function <em>func</em> to each element of the original vector. This method is
similar to <code class="language-plaintext highlighter-rouge">applyAll(*func*)</code>, but rather than
modifying the elements of the original vector, this method creates a new
vector, and leaves the elements of the original vector unchanged. The
return value is the new vector.</p>

<p><code class="language-plaintext highlighter-rouge">maxVal(*func*?)</code></p>

<p>If <em>func</em> is omitted, returns the maximum of the element values in the
vector, comparing values to one another as though using the
<code class="language-plaintext highlighter-rouge">\&gt;</code> operator.</p>

<p>If <em>func</em> is specified, it must be a function pointer. The method calls
<em>func</em>() for each element in the vector, passing the element’s value as
the function argument. The function must return a value. The result of
<code class="language-plaintext highlighter-rouge">maxVal</code> in this case is the value of the
element that maximizes <em>func</em>. Note that the <strong>element value</strong> is
returned, <em>not</em> the return value of <em>func</em>.</p>

<p>For example, if <code class="language-plaintext highlighter-rouge">v</code> is a vector containing
string values, <code class="language-plaintext highlighter-rouge">v.maxVal({x: x.length()})</code>
returns the longest string element.</p>

<p><code class="language-plaintext highlighter-rouge">minVal(*func*?)</code></p>

<p>If <em>func</em> is omitted, returns minimum of the element values in the
vector, comparing values to one another as though using the
<code class="language-plaintext highlighter-rouge">\&lt;</code> operator.</p>

<p>If <em>func</em> is specified, it must be a function pointer. The method calls
<em>func</em>() for each element in the vector, passing the element’s value as
the function argument. The function must return a value. The result of
<code class="language-plaintext highlighter-rouge">minVal</code> in this case is the element value that
minimizes <em>func</em> Note that the <strong>element value</strong> is returned, <em>not</em> the
return value of <em>func</em>.</p>

<p>For example, if <code class="language-plaintext highlighter-rouge">v</code> is a vector containing
string values, <code class="language-plaintext highlighter-rouge">v.minVal({x: x.length()})</code>
returns the shortest string element.</p>

<p><code class="language-plaintext highlighter-rouge">prepend(*val*)</code></p>

<p>Inserts the value <em>val</em> before the first element of the vector,
increasing the vector’s length by one. This method is similar to
<code class="language-plaintext highlighter-rouge">append(*val*)</code>, but inserts the new element at
the start of the vector rather than at the end. Returns
<code class="language-plaintext highlighter-rouge">self</code>.</p>

<p><code class="language-plaintext highlighter-rouge">removeElement(*val*)</code></p>

<p>Deletes one or more elements from the vector; each vector element whose
value equals <em>val</em> is removed from the vector. This reduces the length
of the vector by the number of elements removed. If there is no element
of the vector whose value equals <em>val</em>, the vector is unchanged. Returns
<code class="language-plaintext highlighter-rouge">self</code>.</p>

<p><code class="language-plaintext highlighter-rouge">removeElementAt(*index*)</code></p>

<p>Deletes one element from the vector at the given index. This reduces the
length of the vector by one. The <em>index</em> value must refer to an existing
element of the vector, or the method throws an error (“index out of
range”). Returns <code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>If <em>index</em> is negative, it counts from the end of the vector: -1 is the
last element, -2 is the second to last, and so on.</p>

<p><code class="language-plaintext highlighter-rouge">removeRange(*startingIndex*, *endingIndex*)</code></p>

<p>Deletes elements from the vector from <em>startingIndex</em> through and
including <em>endingIndex</em>. If <em>startingIndex</em> equals <em>endingIndex</em>, this
method simply deletes one element. This reduces the length of the vector
by the number of elements removed.</p>

<p>Either index (or both) can be negative. A negative index counts from the
end of the vector: -1 is the last element, -2 is the second to last,
etc. To delete the last two elements, for example, you can use
<code class="language-plaintext highlighter-rouge">vec.removeRange(-2, -1)</code>.</p>

<p>Both <em>startingIndex</em> and <em>endingIndex</em> must refer to existing elements
of the vector, and the ending index must be greater than or equal to the
starting index; if these conditions don’t hold, the method throws an
error (“index out of range”).</p>

<p>Returns the <code class="language-plaintext highlighter-rouge">self</code> object.</p>

<p><code class="language-plaintext highlighter-rouge">setLength(*newLength*)</code></p>

<p>Sets the number of elements of the vector to <em>newLength</em>. If <em>newLength</em>
is smaller than the number of elements currently in the vector, this
discards elements at the end of the vector. If <em>newLength</em> is larger
than the current size, this adds new elements and sets their values to
<code class="language-plaintext highlighter-rouge">nil</code>. Returns the
<code class="language-plaintext highlighter-rouge">self</code> object.</p>

<p><code class="language-plaintext highlighter-rouge">sort(*descending*?, *comparisonFunction*?)</code></p>

<p>Re-orders the elements of the vector into sorted order. By default, this
method sorts the elements of the vector into ascending order, but you
can reverse this ordering by specifying true for the <em>descending</em>
argument.</p>

<p>The optional <em>comparisonFunction</em> can be used to specify the ordering of
the result. If this argument is not specified (or is
<code class="language-plaintext highlighter-rouge">nil</code>), the method will sort the elements
according to the standard system ordering of values; hence, the elements
must be of comparable types (such as all integers or all strings). By
specifying a comparison function, you can provide your own special
ordering, and you can also sort values that have no system-defined
order, such as object values.</p>

<p>The <em>comparisonFunction</em> works the same way as the for the
<a href="list.html">List</a> class’s <code class="language-plaintext highlighter-rouge">sort()</code> method.</p>

<p><span id="splice"></span></p>

<p><code class="language-plaintext highlighter-rouge">splice(*idx*, *del*, ...)</code></p>

<p>Splices elements into the vector, by replacing a given range of elements
with a set of new elements. <em>idx</em> is the starting index for the splice,
and <em>del</em> is the number of items to delete. The remaining arguments are
values to be inserted in place of the items deleted. The method first
deletes <em>del</em> elements from the list starting at <em>idx</em>, then inserts the
remaining arguments as new elements at the same index. The effect is to
replace the <em>del</em> elements starting at <em>idx</em> with the new list of
elements. The number of new elements can be different from the number of
elements deleted.</p>

<p>If <em>idx</em> is negative, it counts from the end of the vector: -1 is the
last element, -2 is the second to last, and so on. If <em>idx</em> is zero, the
new elements are inserted after the existing last element.</p>

<p>To insert elements without deleting any existing elements, pass 0 for
<em>del</em>. To delete elements without inserting any new elements in their
place, simply omit any additional arguments.</p>

<p>This method modifies the vector in place, and returns
<code class="language-plaintext highlighter-rouge">self</code>.</p>

<p>You can get the same effect as this method using a combination of
<code class="language-plaintext highlighter-rouge">removeRange()</code> and
<code class="language-plaintext highlighter-rouge">insertAt()</code>. <code class="language-plaintext highlighter-rouge">splice()</code>
is clearer and more concise for cases where you want to replace a range
with new values. It’s also a little more efficient, because it minimizes
the number of copy operations needed to move elements around in the
vector to open and/or close gaps as the size of the vector changes.</p>

<p><code class="language-plaintext highlighter-rouge">subset(*func*)</code></p>

<p>Creates and returns a new vector containing the elements of this vector
for which the callback function <em>func</em> returns a non-false value (i.e.,
any value other than <code class="language-plaintext highlighter-rouge">nil</code> or 0). For each
element of the source vector, this method invokes the callback function,
passing the value of the current element as the callback function’s
single argument. If the callback returns <code class="language-plaintext highlighter-rouge">nil</code>
or 0, the method omits the element from the result; otherwise, the
method includes the element in the result vector. The new vector’s
elements will be in the same order as the selected elements from the
source vector.</p>

<p>This method does not modify the original vector.</p>

<p>This example uses a short-form anonymous function to create to create a
new vector that contains only the elements from an original vector whose
values are greater than 10.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    y = x.subset({x: x &gt; 10});
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">toList(*start*?, *count*?)</code></p>

<p>Creates and returns a new list value based on the vector. With no
arguments, the new list has the same number of elements as the original
vector, and each element of the list is a copy of the corresponding
element of the vector. If <em>start</em> is specified, it gives the starting
index in the vector for the list; elements of the vector before start
are not included in the list. If <em>count</em> is specified, it indicates the
number of elements of the vector, starting at start, to copy into the
list.</p>

<p>This method is useful when you need to pass a value to a routine that
requires a list value. Vectors cannot always be passed to routines
requiring list values, so you can use this routine to create a list with
the same values as the vector.</p>

<p>This method does not modify the vector.</p>

<p><code class="language-plaintext highlighter-rouge">valWhich(*cond*)</code></p>

<p>Returns the value of the first element for which the callback function
<em>cond</em> returns a non-false value (i.e., any value other than
<code class="language-plaintext highlighter-rouge">nil</code> or 0). The method applies the callback to
each element of the vector, starting with the first, and calls the
function for each element in turn until <em>cond</em> returns a non-false
value. Returns <code class="language-plaintext highlighter-rouge">nil</code> if the callback returns a
false value for every element. This function is almost the same as
<code class="language-plaintext highlighter-rouge">indexWhich(*cond*)</code>, but returns the value of
the first element for which <em>cond</em> returns non-false rather than the
index of the element. Returns <code class="language-plaintext highlighter-rouge">nil</code> if no
matching value is found.</p>

<h2 id="reference-semantics">Reference Semantics</h2>

<p>The most important distinction between lists and vectors, and the
primary reason to use vectors rather than lists in certain situations,
is that vectors use “reference” semantics, while lists use “value”
semantics.</p>

<p>The difference is that a list’s value can never change, but an vector’s
value can change.</p>

<p>When you do something that modifies a list, such as assigning a value to
an element of the list, the operation does not change the list. Instead,
it creates a new list that reflects the change, leaving the original
list unmodified. TADS automatically updates the variable that contained
the list being indexed so that it contains the newly-created list.</p>

<p>In contrast, when you assign a new value to an element of an vector, the
vector’s value is changed. No new vector object is created.</p>

<p>This might seem like a very obscure difference, but it has two important
practical effects. The first is that operations that modify vectors are
much cheaper to execute, because they don’t result in creating new
objects; this means that operations involving a large number of element
changes will run faster with vectors than with lists.</p>

<p>The second practical difference is that, whenever you change a vector,
the change is visible everywhere the vector is referenced. In contrast,
when you change a list, the change is visible only to the code that made
the change.</p>

<p>Consider this example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local a = [1, 2, 3];
    local b = a;

    a[2] = 100;
    tadsSay(b[2]);
</code></pre></div></div>

<p>What will this example display? At the beginning of the code, we set a
to a list, and then we set b to the value in a, so b refers to the same
list. So far we have only one object, and both a and b refer to this
single object. We next assign a new value, 100, to the second element of
a. As we’ve seen, this cannot change the list that a refers to, because
lists can never change; so, what we’re doing is creating a new list,
copying each element from the original list to the new list, but
changing the second element to reflect the assignment. This new list is
then assigned to a, so a and b now refer to different lists. So, when we
display the second element of b, we see the value “2” displayed, because
b still refers to the original, unmodified list.</p>

<p>Now, consider the same example with an vector:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    local a = new Vector(10, [1, 2, 3]);
    local b = a;

    a[2] = 100;
    tadsSay(b[2]);
</code></pre></div></div>

<p>This code looks almost identical, but it displays a different result
than the list version. We start out by creating a new vector object and
assigning it to a, and then we assign the same value to b. Next, we
assign 100 to the second element of a. Unlike lists, vectors can be
changed, so this assignment simply replaces the value in the vector
object’s second element. No new vector object is created, so a and b
still refer to the same object. So, when we display b[2] in this
example, we see the modified value.</p>

<p>Here’s a more interesting example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    f1()
    {
      local a = new Vector(3);

      getInfo(a);
      "Thanks, &lt;&lt;a[1]&gt;&gt;!  This information will allow us to send
      you specially targeted advertising based on your credit
      history! ";
    }

    getInfo(x)
    {
      "Please enter your name: "; x[1] = input();
      "Please enter your age: "; x[2] = toInteger(input());
      "Please enter your social security number: "; x[3] = input();
    }
</code></pre></div></div>

<p>This is something we couldn’t have done with lists: assigning elements
of x in getInfo() wouldn’t have affected the caller’s copy of the list,
so the routine wouldn’t be able to pass back information this way using
lists.</p>

<p>Note that, when you explicitly create a copy of a vector, the new copy
is not affected by any changes to the original:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    x = new Vector(10, [1, 2, 3, 4, 5]);
    y = new Vector(10, x);

    x[3] = 100;
    tadsSay(y[3]);
</code></pre></div></div>

<p>This example displays the value “3” (not “100”), because x and y refer
to separate objects. Changing a value in the vector to which x refers
has no effect on the vector to which y refers.</p>

<hr />

<p><em>TADS 3 System Manual</em><br />
<a href="toc.html" class="nav">Table of Contents</a> |
<a href="builtins.html" class="nav">The Intrinsics</a> &gt; Vector<br />
<span class="navnp"><a href="timezone.html" class="nav"><em>Prev:</em> TimeZone</a>
   
<a href="wlookup.html" class="nav"><em>Next:</em> WeakRefLookupTable</a>
    </span></p>


</main>
<footer>
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>