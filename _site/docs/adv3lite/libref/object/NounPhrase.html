<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="website">
    <link rel="icon" href="/assets/images/tads-favicon.png" type="image/png">
    <link rel="stylesheet" type="text/css"
                           href="/assets/css/styles.css">
    <title></title>
    <meta property="og:title" content=
    "">
    <meta name="description" content="">
    <meta property="og:description" content="">
</head>
<header id="header"><div class="header-search">
    <form class="header-search-form" action="/search" method="get">
      <input type="text" id="search-box" name="query">
      <input type="submit" value="search">
    </form>
  </div>  </header>
<body>
<main id="content">
<p><span class="title">NounPhrase</span><span class="type">class</span></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1646">1646</a>]</p>

<p><a href="#_SuperClassTree_">Superclass<br />
Tree</a></p>

<p><a href="#_SubClassTree_">Subclass<br />
Tree</a></p>

<p><a href="#_ObjectSummary_">Global<br />
Objects</a></p>

<p><a href="#_PropSummary_">Property<br />
Summary</a></p>

<p><a href="#_MethodSummary_">Method<br />
Summary</a></p>

<p><a href="#_Properties_">Property<br />
Details</a></p>

<p><a href="#_Methods_">Method<br />
Details</a></p>

<p>A NounPhrase object represents a noun phrase within a command line. This
class handles the mapping from the text of the noun phrase in the input
to the game-world objects that the noun phrase refers to.</p>

<p>This object encompasses a core noun phrase plus all of its qualifiers.
Qualifiers can themselves be noun phrases: possessives, locationals, and
contents phrases contain subsidiary noun phrases, so we represent these
qualifiers with subsidiary NounPhrase objects.</p>

<p><code class="language-plaintext highlighter-rouge">class </code><strong><code class="language-plaintext highlighter-rouge">NounPhrase</code></strong><code class="language-plaintext highlighter-rouge"> :   object</code></p>

<p><span id="_SuperClassTree_"></span></p>

<p><span class="hdln">Superclass Tree</span>   (in declaration order)</p>

<p><strong><code class="language-plaintext highlighter-rouge">NounPhrase</code></strong><br />
`         object`<br />
<span id="_SubClassTree_"></span></p>

<p><span class="hdln">Subclass Tree</span>  </p>

<p><strong><code class="language-plaintext highlighter-rouge">NounPhrase</code></strong><br />
<a href="../object/LiteralPhrase.html"><code class="language-plaintext highlighter-rouge">LiteralPhrase</code></a><br />
<a href="../object/NumberPhrase.html"><code class="language-plaintext highlighter-rouge">NumberPhrase</code></a><br />
<a href="../object/TopicPhrase.html"><code class="language-plaintext highlighter-rouge">TopicPhrase</code></a><br />
<span id="_ObjectSummary_"></span></p>

<p><span class="hdln">Global Objects</span>  </p>

<p><em>(none)</em> <span id="_PropSummary_"></span></p>

<p><span class="hdln">Summary of Properties</span>  </p>

<p><a href="#contPrep"><code class="language-plaintext highlighter-rouge">contPrep</code></a> <a href="#contQual"><code class="language-plaintext highlighter-rouge">contQual</code></a> <a href="#coreProd"><code class="language-plaintext highlighter-rouge">coreProd</code></a> <a href="#determiner"><code class="language-plaintext highlighter-rouge">determiner</code></a> <a href="#disambigNameList"><code class="language-plaintext highlighter-rouge">disambigNameList</code></a> <a href="#errName"><code class="language-plaintext highlighter-rouge">errName</code></a> <a href="#errNameProd"><code class="language-plaintext highlighter-rouge">errNameProd</code></a> <a href="#exclusions"><code class="language-plaintext highlighter-rouge">exclusions</code></a> <a href="#locQual"><code class="language-plaintext highlighter-rouge">locQual</code></a> <a href="#locType"><code class="language-plaintext highlighter-rouge">locType</code></a> <a href="#matches"><code class="language-plaintext highlighter-rouge">matches</code></a> <a href="#objs"><code class="language-plaintext highlighter-rouge">objs</code></a> <a href="#ordinal"><code class="language-plaintext highlighter-rouge">ordinal</code></a> <a href="#parent"><code class="language-plaintext highlighter-rouge">parent</code></a> <a href="#possQual"><code class="language-plaintext highlighter-rouge">possQual</code></a> <a href="#prod"><code class="language-plaintext highlighter-rouge">prod</code></a> <a href="#pronoun"><code class="language-plaintext highlighter-rouge">pronoun</code></a> <a href="#quantifier"><code class="language-plaintext highlighter-rouge">quantifier</code></a> <a href="#role"><code class="language-plaintext highlighter-rouge">role</code></a> <a href="#tokens"><code class="language-plaintext highlighter-rouge">tokens</code></a></p>

<p><span id="_MethodSummary_"></span></p>

<p><span class="hdln">Summary of Methods</span>  </p>

<p><a href="#addContents"><code class="language-plaintext highlighter-rouge">addContents</code></a> <a href="#addExclusionItem"><code class="language-plaintext highlighter-rouge">addExclusionItem</code></a> <a href="#addLiteral"><code class="language-plaintext highlighter-rouge">addLiteral</code></a> <a href="#addLocation"><code class="language-plaintext highlighter-rouge">addLocation</code></a> <a href="#addMatches"><code class="language-plaintext highlighter-rouge">addMatches</code></a> <a href="#addOrdinal"><code class="language-plaintext highlighter-rouge">addOrdinal</code></a> <a href="#addPossessive"><code class="language-plaintext highlighter-rouge">addPossessive</code></a> <a href="#addQuantifier"><code class="language-plaintext highlighter-rouge">addQuantifier</code></a> <a href="#ambigError"><code class="language-plaintext highlighter-rouge">ambigError</code></a> <a href="#applyContQual"><code class="language-plaintext highlighter-rouge">applyContQual</code></a> <a href="#applyDisambig"><code class="language-plaintext highlighter-rouge">applyDisambig</code></a> <a href="#applyExclusion"><code class="language-plaintext highlighter-rouge">applyExclusion</code></a> <a href="#applyLocational"><code class="language-plaintext highlighter-rouge">applyLocational</code></a> <a href="#applyPossessive"><code class="language-plaintext highlighter-rouge">applyPossessive</code></a> <a href="#buildObjList"><code class="language-plaintext highlighter-rouge">buildObjList</code></a> <a href="#clone"><code class="language-plaintext highlighter-rouge">clone</code></a> <a href="#construct"><code class="language-plaintext highlighter-rouge">construct</code></a> <a href="#contains"><code class="language-plaintext highlighter-rouge">contains</code></a> <a href="#disambiguate"><code class="language-plaintext highlighter-rouge">disambiguate</code></a> <a href="#expandErrName"><code class="language-plaintext highlighter-rouge">expandErrName</code></a> <a href="#isAllEquivalent"><code class="language-plaintext highlighter-rouge">isAllEquivalent</code></a> <a href="#isMultiple"><code class="language-plaintext highlighter-rouge">isMultiple</code></a> <a href="#matchNameScope"><code class="language-plaintext highlighter-rouge">matchNameScope</code></a> <a href="#matchVocab"><code class="language-plaintext highlighter-rouge">matchVocab</code></a> <a href="#matchVocabPoss"><code class="language-plaintext highlighter-rouge">matchVocabPoss</code></a> <a href="#resolveAll"><code class="language-plaintext highlighter-rouge">resolveAll</code></a> <a href="#resolveReflexives"><code class="language-plaintext highlighter-rouge">resolveReflexives</code></a> <a href="#selectObjects"><code class="language-plaintext highlighter-rouge">selectObjects</code></a></p>

<p><span id="_Properties_"></span></p>

<p><span class="hdln">Properties</span>  </p>

<p><span id="contPrep"></span></p>

<p><code class="language-plaintext highlighter-rouge">contPrep</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2924">2924</a>]</p>

<p>the preposition of the contents qualifier</p>

<p><span id="contQual"></span></p>

<p><code class="language-plaintext highlighter-rouge">contQual</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2921">2921</a>]</p>

<p>the contents qualifier phrase, if any (“the bucket OF WATER”)</p>

<p><span id="coreProd"></span></p>

<p><code class="language-plaintext highlighter-rouge">coreProd</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2899">2899</a>]</p>

<p>the grammar match for the core noun phrase; this is the part that names
a single object, stripped of all qualifiers (such as possessives,
articles, quantifiers, and locational phrases)</p>

<p><span id="determiner"></span></p>

<p><code class="language-plaintext highlighter-rouge">determiner</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2937">2937</a>]</p>

<p>the determiner, if any, as a Determiner object</p>

<p><span id="disambigNameList"></span></p>

<p><code class="language-plaintext highlighter-rouge">disambigNameList</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2946">2946</a>]</p>

<p>the name list from the disambiguation query</p>

<p><span id="errName"></span></p>

<p><code class="language-plaintext highlighter-rouge">errName</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1696">1696</a>]</p>

<p>By default, use the original input text of my “core” production as the
name we show for this noun phrase in error messages. The core production
is the noun phrase minus any qualifiers (articles, possessives,
locational phrases, etc).</p>

<p>As we successfully resolve qualifiers, we’ll expand this to include the
qualifying phrases. Any error we find after resolving a qualifier will
necessary apply to the qualified form, so we want to include the
qualifier in any error message.</p>

<p>For example, if the original phrase is BUCKET OF FISH ON TABLE, we’ll
start out with the core phrase of BUCKET. We’ll next resolve the
contents qualifier, OF FISH. Assuming that we find a BUCKET OF FISH,
that becomes the new error name. If we then fail to find such an object
ON TABLE, we’ll be able to report that there’s no BUCKET OF FISH on the
table. This is better than reporting that we don’t see any BUCKET on the
table, because there could in fact be a different bucket on the table.</p>

<p><span id="errNameProd"></span></p>

<p><code class="language-plaintext highlighter-rouge">errNameProd</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1699">1699</a>]</p>

<p>the source of the error name is initially the core production</p>

<p><span id="exclusions"></span></p>

<p><code class="language-plaintext highlighter-rouge">exclusions</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2943">2943</a>]</p>

<p>the exclusion list, if any (this is the list following EXCEPT or BUT in
a phrase like ALL EXCEPT THE RED ONES)</p>

<p><span id="locQual"></span></p>

<p><code class="language-plaintext highlighter-rouge">locQual</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2911">2911</a>]</p>

<p>the locational qualifier phrase, if any (“the box ON THE SHELF”)</p>

<p><span id="locType"></span></p>

<p><code class="language-plaintext highlighter-rouge">locType</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2918">2918</a>]</p>

<p>The locational qualifier relationship, as a LocType object. (This is
stored on the locational qualifier noun phrase itself, not on the
underlying noun phrase it qualifies.)</p>

<p><span id="matches"></span></p>

<p><code class="language-plaintext highlighter-rouge">matches</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2797">2797</a>]</p>

<p>List of NPMatch objects. This is populated during the matchName phase
with the list of possible vocabulary matches, and then reduced during
disambiguation to the final set.</p>

<p><span id="objs"></span></p>

<p><code class="language-plaintext highlighter-rouge">objs</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2804">2804</a>]</p>

<p>List of resolved objects. This is populated after disambiguation from
the ‘matches’ set - it contains the same objects, but simply the objects
rather than the NPMatch wrappers.</p>

<p><span id="ordinal"></span></p>

<p><code class="language-plaintext highlighter-rouge">ordinal</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2934">2934</a>]</p>

<p>The ordinal value, if any, as a number: for “the third one”, this is 3.
This is intended for use in disambiguation replies, to let the user pick
out an item by its position in the offered list.</p>

<p><span id="parent"></span></p>

<p><code class="language-plaintext highlighter-rouge">parent</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2889">2889</a>]</p>

<p>the NounPhrase we qualify, if we’re a possessive or locational</p>

<p><span id="possQual"></span></p>

<p><code class="language-plaintext highlighter-rouge">possQual</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2908">2908</a>]</p>

<p>the possessive qualifier, if any (“BOB’S box”)</p>

<p><span id="prod"></span></p>

<p><code class="language-plaintext highlighter-rouge">prod</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2892">2892</a>]</p>

<p>the grammar production match object for this noun phrase</p>

<p><span id="pronoun"></span></p>

<p><code class="language-plaintext highlighter-rouge">pronoun</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2905">2905</a>]</p>

<p>the pronoun, if any, as a Pronoun object</p>

<p><span id="quantifier"></span></p>

<p><code class="language-plaintext highlighter-rouge">quantifier</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2927">2927</a>]</p>

<p>the quantifier, if any, as a number: for “five books”, this is 5</p>

<p><span id="role"></span></p>

<p><code class="language-plaintext highlighter-rouge">role</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2886">2886</a>]</p>

<p>the Command list we’re a part of (&amp;dobjNPs, &amp;iobjNPs, etc: the Command
overrides this to the actual list property for a primary noun phrase,
and for qualifiers such as possessives, this inherited version looks it
up via the parent)</p>

<p><span id="tokens"></span></p>

<p><code class="language-plaintext highlighter-rouge">tokens</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2902">2902</a>]</p>

<p>the literal tokens making up the noun phrase</p>

<p><span id="_Methods_"></span></p>

<p><span class="hdln">Methods</span>  </p>

<p><span id="addContents"></span></p>

<p><code class="language-plaintext highlighter-rouge">addContents (prep, prod)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2817">2817</a>]</p>

<p>add a contents qualifier, returning the new noun phrase</p>

<p><span id="addExclusionItem"></span></p>

<p><code class="language-plaintext highlighter-rouge">addExclusionItem (prod)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2852">2852</a>]</p>

<p>add an exclusion list item</p>

<p><span id="addLiteral"></span></p>

<p><code class="language-plaintext highlighter-rouge">addLiteral (tok)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2807">2807</a>]</p>

<p>add a literal to this phrase</p>

<p><span id="addLocation"></span></p>

<p><code class="language-plaintext highlighter-rouge">addLocation (locType, prod)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2827">2827</a>]</p>

<p>add a locational qualifier, returning the new noun phrase</p>

<p><span id="addMatches"></span></p>

<p><code class="language-plaintext highlighter-rouge">addMatches (vec, lst, match)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1870">1870</a>]</p>

<p>Add matching objects to a match vector. ‘lst’ can be a list or vector of
objects, or a single object. ‘match’ is the MatchXxx flag value returned
from the object name match, if applicable.</p>

<p><span id="addOrdinal"></span></p>

<p><code class="language-plaintext highlighter-rouge">addOrdinal (num)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2846">2846</a>]</p>

<p>add an ordinal, given as an integer value</p>

<p><span id="addPossessive"></span></p>

<p><code class="language-plaintext highlighter-rouge">addPossessive (prod)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2810">2810</a>]</p>

<p>add a possessive qualifier, returning the new noun phrase</p>

<p><span id="addQuantifier"></span></p>

<p><code class="language-plaintext highlighter-rouge">addQuantifier (num)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2840">2840</a>]</p>

<p>add a quantifier, given as an integer value</p>

<p><span id="ambigError"></span></p>

<p><code class="language-plaintext highlighter-rouge">ambigError (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2436">2436</a>]</p>

<p>Throw an ambiguous noun phrase error for the current match list.</p>

<p><span id="applyContQual"></span></p>

<p><code class="language-plaintext highlighter-rouge">applyContQual ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2101">2101</a>]</p>

<p>Apply this contents qualifier phrase’s qualification. This filters the
underlying (parent) noun list to keep only objects that contain the
object(s) named in this noun list.</p>

<p><span id="applyDisambig"></span></p>

<p><code class="language-plaintext highlighter-rouge">applyDisambig (cmd, ambigMatches, nameList)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2509">2509</a>]</p>

<p>Apply this noun phrase as a disambiguation reply to the given original
list of matches to an ambiguous noun phrase.</p>

<p><span id="applyExclusion"></span></p>

<p><code class="language-plaintext highlighter-rouge">applyExclusion (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2168">2168</a>]</p>

<p>Apply an exclusion item. This resolves the vocabulary for the exclusion
phrase and filters the matching item(s) noun phrase out of the parent
list.</p>

<p><span id="applyLocational"></span></p>

<p><code class="language-plaintext highlighter-rouge">applyLocational ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2130">2130</a>]</p>

<p>Apply this locational phrase’s qualification. This filters the
underlying (parent) noun list to keep only objects located within the
object(s) named in this noun phrase.</p>

<p><span id="applyPossessive"></span></p>

<p><code class="language-plaintext highlighter-rouge">applyPossessive ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2064">2064</a>]</p>

<p>Apply this possessive phrase’s qualification. This filters the
underlying (parent) noun list to keep only objects owned by the
object(s) named in this noun phrase.</p>

<p><span id="buildObjList"></span></p>

<p><code class="language-plaintext highlighter-rouge">buildObjList ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2787">2787</a>]</p>

<p>Build the ‘objs’ list from the match list</p>

<p><span id="clone"></span></p>

<p><code class="language-plaintext highlighter-rouge">clone ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1659">1659</a>]</p>

<p>clone - create a modifiable copy based on this original noun phrase</p>

<p><span id="construct"></span></p>

<p><code class="language-plaintext highlighter-rouge">construct (parent, prod)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1648">1648</a>]</p>

<p>create</p>

<p><span id="contains"></span></p>

<p><code class="language-plaintext highlighter-rouge">contains (np)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1734">1734</a>]</p>

<p>Does this NounPhrase contain the given NounPhrase? Returns true if
NounPhrase is self, or one of our qualifier noun phrases contains it.</p>

<p><span id="disambiguate"></span></p>

<p><code class="language-plaintext highlighter-rouge">disambiguate (cmd, num, action)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2347">2347</a>]</p>

<p>Disambiguate the match list to select the given target number of
objects.</p>

<p><span id="expandErrName"></span></p>

<p><code class="language-plaintext highlighter-rouge">expandErrName (np)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1706">1706</a>]</p>

<p>Expand the error-message name to include the given qualifier. We’ll find
the common parent of the core production and the given qualifier’s
production, and use its text as the new error name.</p>

<p><span id="isAllEquivalent"></span></p>

<p><code class="language-plaintext highlighter-rouge">isAllEquivalent (matchList)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2337">2337</a>]</p>

<p>Determine whether all matches in the matchList are impossible to
disambiguate.</p>

<p><span id="isMultiple"></span></p>

<p><code class="language-plaintext highlighter-rouge">isMultiple ( )</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2873">2873</a>]</p>

<p>Does this noun phrase refer to multiple objects structurally? This is
true if any the matches used plural words, or the determiner is All, or
we have a quantifier greater than 1.</p>

<p><span id="matchNameScope"></span></p>

<p><code class="language-plaintext highlighter-rouge">matchNameScope (cmd, scope)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1884">1884</a>]</p>

<p>Find the vocabulary matches for a given noun phrase within a given scope
list. Add all of the matches to the given vector.</p>

<p><span id="matchVocab"></span></p>

<p><code class="language-plaintext highlighter-rouge">matchVocab (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1750">1750</a>]</p>

<p>Get the list of objects matching the vocabulary words in our noun
phrase. Populates our ‘matches’ property with a vector of matching
objects. This doesn’t look at any of our qualifiers, or attempt to
disambiguate contextually; it simply finds everything in scope that the
noun phrase could refer to.</p>

<p><span id="matchVocabPoss"></span></p>

<p><code class="language-plaintext highlighter-rouge">matchVocabPoss (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1950">1950</a>]</p>

<p>Match vocabulary for a possessive qualifier phrase.</p>

<p>Possessive matching has somewhat different rules than for ordinary noun
phrases.</p>

<p>First, possessive pronouns (HIS, HER, ITS, THEIR) *can* act like
reflexives, in that they can refer back to earlier clauses in the same
predicate: ASK BOB ABOUT HIS MOTHER. However, they can also refer to
previous commands: SEARCH BOB; TAKE HIS WALLET. The deciding factor is
whether or not there’s an earlier noun phrase in the command that
matches in gender and number; if so, we use the reflexive meaning,
otherwise we use the external referent.</p>

<p>Second, the scope for ordinary noun phrases has to be expanded to
include the owners of the objects in scope. If we have a wallet that we
know belongs to Bob, we should be able to refer to it as “Bob’s wallet”
whether or not Bob himself is in scope. So, for the purposes of the
possessive, Bob is in scope even if he wouldn’t be for an ordinary noun
phrase.</p>

<p><span id="resolveAll"></span></p>

<p><code class="language-plaintext highlighter-rouge">resolveAll (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2706">2706</a>]</p>

<p>Resolve ALL. This is called on a separate pass after selectObjects(),
because two-object verbs sometimes resolve ALL in one slot according to
the selection in the other slot.</p>

<p><span id="resolveReflexives"></span></p>

<p><code class="language-plaintext highlighter-rouge">resolveReflexives (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2751">2751</a>]</p>

<p>Resolve reflexive pronouns. Our Command calls this AFTER resolving all
of the regular noun phrases, because reflexives refer back to other
nouns in the same command.</p>

<p><span id="selectObjects"></span></p>

<p><code class="language-plaintext highlighter-rouge">selectObjects (cmd)</code></p>

<p><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2219">2219</a>]</p>

<p>Select the objects from among the vocabulary matches. This narrows the
list of possible vocabulary matches for our noun phrase to find the
actual object or objects the player is referencing.</p>

<p>When this is called, we’ve already filled in the match list with all
objects in scope that match the vocabulary of the core noun phrase
(including non-reflexive pronouns and ALL), and we’ve applied any
possessive, locational, and exclusion qualifiers. What we’re left with
is the list of in-scope objects that meet all of the specifications
contained in the entire noun phrase. In other words, we’ve squeezed all
available information out of the noun phrase itself. If the result is
ambiguous, then, we’ll have to look beyond the noun phrase, to the
broader semantic content of the overall command.</p>

<p>There are three possible “goals” for what our final object list should
look like after disambiguation. Only one goal applies to each particular
noun phrase; which it is depends on the grammar of the phrase:</p>

<p>1. Definite mode: TAKE BOOK, TAKE THE BOOK, TAKE BOTH BOOKS, TAKE THE
THREE BOOKS. The goal in definite mode is to choose the given number of
objects, *and* to make sure that the player could *only* have meant
those precise objects. In other words, we’re not allowed to make an
arbitrary choice: in natural language, the definite mode says that the
speaker believes the listener knows which *particular* object or
objects the speaker is referring to. If we’re not absolutely sure which
objects the player is talking about, we have a disagreement with the
player’s apparent expectations and must ask for clarification.</p>

<p>2. Indefinite mode: TAKE A BOOK, TAKE ANY BOOK, TAKE TWO BOOKS. The
goal is to choose the given number of objects from the possible matches,
arbitrarily choosing from the available objects.</p>

<p>3. Plural mode: TAKE BOOKS, TAKE THE BOOKS, TAKE ALL BOOKS. The goal
here is to choose all of the matching objects.
Adv3Lite Library Reference Manual<br />
Generated on 15/03/2023 from adv3Lite version 1.6.1</p>


</main>
<footer id="footer">
    <p>This is an unofficial informational website to aggregate TADS 3 information and does not claim authorship over, or any rights to, TADS 3 itself. All resources copyright their credited owners. TADS itself is <a href="https://www.tads.org/copyright.htm">Copyright ©2001-2013 Michael J. Roberts</a>.</p>
    <p><a href="/">Back to Homepage</a></p>
</footer>
</body>
</html>

<script>
    if(window.location !== window.top.location) {
        let header = document.getElementById('header');
        let footer = document.getElementById('footer');
        header.remove();
        footer.remove();
    }
</script>